# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-05-29T17:36:52+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    PositiveFloat,
    RootModel,
    StrictBool,
    StrictStr,
    confloat,
    conint,
    constr,
)


class MetricResult(BaseModel):
    value: Optional[float] = Field(None, description="The computed value of the metric, or null if it failed.")
    error: Optional[StrictStr] = Field(None, description="Error message if the metric could not be computed.")


class StatsResponse(BaseModel):
    metrics: Optional[Dict[str, MetricResult]] = Field(
        None, description="A dictionary of computed metrics and their results or errors."
    )


class ReturnPeriod(Enum):
    D = "D"
    W = "W"
    M = "M"
    Y = "Y"


class BenchmarkType(Enum):
    MERQUBE_INDEX = "MERQUBE_INDEX"
    EQUITY = "EQUITY"


class IdentifierType(Enum):
    TICKER = "TICKER"
    FSYM_ID = "FSYM_ID"


class Benchmark(BaseModel):
    benchmark_type: Optional[BenchmarkType] = Field(None, examples=["MERQUBE_INDEX"])
    identifier_type: IdentifierType = Field(..., examples=["TICKER"])
    identifier: StrictStr = Field(..., examples=["MY_INDEX_NAME"])
    metric: Optional[StrictStr] = Field(None, examples=["index_level"])


class StatsRequest(BaseModel):
    start_date: Optional[date] = Field(None, examples=["2006-12-29"])
    end_date: Optional[date] = Field(None, examples=["2006-12-29"])
    index_metric: StrictStr = Field("price_return", examples=["price_return"])
    target_return: Optional[confloat(ge=0.0)] = Field(None, examples=[0])
    return_period: ReturnPeriod = Field(..., examples=["D"])
    benchmark: Optional[Benchmark] = None


class AlertHours(BaseModel):
    start: Optional[constr(pattern=r"^[0-2]{1}[0-9]{1}:[0-5]{1}[0-9]{1}$", strict=True)] = Field(
        None, description="Start of the silent hours in HH:MM 24h format. The timezone is based on the intraday.tzinfo"
    )
    end: Optional[constr(pattern=r"^[0-2]{1}[0-9]{1}:[0-5]{1}[0-9]{1}$", strict=True)] = Field(
        None, description="Start of the silent hours in HH:MM 24h format. The timezone is based on the intraday.tzinfo"
    )


class IntradayFlatlineAlerts(BaseModel):
    enabled: StrictBool = Field(True, description="If the flatline alert should be enabled")
    window_length: conint(ge=1) = Field(5, description="window_length in minutes for flatline alert")
    min_ticks: conint(ge=2) = Field(
        5, description="Minimum number of ticks in the window to be the same to considered a flatline"
    )
    alert_hours: Optional[AlertHours] = None


class IntradayAlerting(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    flatline_alerts: Optional[IntradayFlatlineAlerts] = None


class Role(Enum):
    data_point = "data point"
    verification = "verification"
    calculation = "calculation"
    development = "development"
    administration = "administration"


class Client(BaseModel):
    requested_by: Optional[StrictStr] = Field(
        None,
        description="this is the actual OAuth token email that originated the POST on index-template (similar to created_by and last_modified_by). Except, this is the user on the templating POST not the actual POST to index because the post to index is going to be a MerQube employee, but we need to capture who originated the templating request aka who called the meta-api. This field is used to put this index on that user's Manage My Indices page.",
    )
    approved_by: Optional[StrictStr] = Field(
        None,
        description="if a client requests an index to a finanancial institution, and that instituion approves the index parameters for launch, this holds the oauth email of that approver",
    )
    owner: Optional[StrictStr] = Field(
        None,
        description="the idea here is to capture the client at a higher level than the above, e.g., this index is owned by Bank of Greatness.",
    )


class CalcFreq(Enum):
    Daily = "Daily"
    Daily__EOD = "Daily, EOD"
    Intraday = "Intraday"


class DisplayMonth(Enum):
    Jan = "Jan"
    Feb = "Feb"
    Mar = "Mar"
    Apr = "Apr"
    May = "May"
    Jun = "Jun"
    Jul = "Jul"
    Aug = "Aug"
    Sep = "Sep"
    Oct = "Oct"
    Nov = "Nov"
    Dec = "Dec"


class FieldModel(BaseModel):
    display_name: Optional[StrictStr] = None
    field_name: Optional[StrictStr] = None


class PortfolioDisplay(BaseModel):
    fields: Optional[List[FieldModel]] = None


class Stage(Enum):
    prod = "prod"
    test = "test"
    development = "development"


class WeightingMethod(Enum):
    Other = "Other"
    Equal = "Equal"


class RebalFrequency(Enum):
    Annual = "Annual"
    Daily = "Daily"
    Monthly = "Monthly"
    Quarterly = "Quarterly"
    Semi_Annual = "Semi-Annual"
    Weekly = "Weekly"
    Bi_Monthly = "Bi-Monthly"
    Intraday = "Intraday"
    None_ = "None"


class IndexSpec(BaseModel):
    index_class: Optional[StrictStr] = None
    index_class_code: Optional[StrictStr] = None
    index_class_args: Optional[Dict[str, Any]] = None
    index_variables: Optional[Dict[str, Any]] = Field(None, description="TODO")
    version: Optional[int] = None


class AlertType(Enum):
    email = "email"
    slack = "slack"
    opsgenie = "opsgenie"
    fail_computation = "fail_computation"


class BaseCheck(BaseModel):
    metric: StrictStr
    enabled: StrictBool
    alert_type: AlertType = AlertType.fail_computation


class LevelCheckParams(BaseModel):
    min: Optional[float] = Field(...)
    max: Optional[float] = Field(...)


class LevelCheck(BaseCheck):
    check_type: Literal["LEVEL_CHECK"]
    params: LevelCheckParams


class PercentChangeCheckParams(BaseModel):
    min: Optional[confloat(ge=-100.0, le=0.0)] = Field(...)
    max: Optional[confloat(ge=0.0, le=100.0)] = Field(...)


class PercentChangeCheck(BaseCheck):
    check_type: Literal["PERCENT_CHANGE_CHECK"]
    params: PercentChangeCheckParams


class HistoryCheckParams(BaseModel):
    days: Optional[conint(ge=0, le=365)] = Field(...)


class HistoryCheck(BaseCheck):
    check_type: Literal["HISTORY_CHECK"]
    params: HistoryCheckParams


class Type(Enum):
    security = "security"
    index = "index"


class Related(BaseModel):
    default_display: StrictBool = False
    id: StrictStr
    metric: Optional[StrictStr] = None
    name: StrictStr
    type: Type


class ChartType(Enum):
    line = "line"
    spline = "spline"
    area = "area"
    bar = "bar"
    column = "column"


class CompareMode(Enum):
    absolute = "absolute"
    percent = "percent"


class ConstructorType(Enum):
    chart = "chart"
    stockChart = "stockChart"


class Value(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    display_name: StrictStr
    path: StrictStr


class Datum(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    url: StrictStr
    array_field: StrictStr
    values: List[Value]
    key_field: StrictStr


class CustomCharts(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: StrictStr
    xlabel: StrictStr
    ylabel: StrictStr
    chart_type: ChartType = ChartType.line
    compare_mode: CompareMode = CompareMode.percent
    constructor_type: ConstructorType = ConstructorType.stockChart
    size: float = 12
    data: Optional[List[Datum]] = None


class IndexBenchmark(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ticker: StrictStr = Field(
        ..., description="accepts either FSYM_ID, or MQI:XXX to benchmark against another index.", examples=["MQI:XXX"]
    )
    threshold: float = Field(
        ...,
        description="the deviation that triggers an outlier event, IE, the daily difference of the index vs the daily difference of the underlying should not be more than this percent",
        examples=[0.05],
    )
    index_metric: StrictStr = Field(
        "price_return",
        description="the metric of this index to compare against the ticker/threshold, eg can compare some other metric of this index than price_return",
        examples=["total_return"],
    )
    benchmark_metric: StrictStr = Field(
        "price_return",
        description="only accepted if the ticker is an MQI. The metric of the benchmark index to compare against; eg can compare to some other metric than price_return of the benchmark",
        examples=["total_return"],
    )


class Provider(Enum):
    bloomberg = "bloomberg"
    reuters = "reuters"
    morningstar = "morningstar"
    factset = "factset"
    nasdaq = "nasdaq"
    wind = "wind"
    secapi = "secapi"


class BloombergProviderKwargsPostType(Enum):
    EOD = "EOD"
    RT = "RT"
    EOD_AND_RT = "EOD_AND_RT"


class BloombergProviderKwargs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    post_type: BloombergProviderKwargsPostType


class ReutersProviderKwargsPostType(Enum):
    EOD = "EOD"
    RT = "RT"
    EOD_AND_RT = "EOD_AND_RT"
    EOD_AND_RT_COMBINED = "EOD_AND_RT_COMBINED"


class ReutersProviderKwargs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    post_type: Optional[ReutersProviderKwargsPostType] = None


class SecapiProviderKwargs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    security_type: StrictStr
    security_name: StrictStr
    metric: StrictStr


class NasdaqEnv(Enum):
    testing = "testing"
    production = "production"


class NasdaqProviderKwargs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    nasdaq_env: NasdaqEnv = Field(..., description="Which Nasdaq environment to send data to")
    eod_date_delta: Optional[int] = Field(
        None,
        description="How many days to offset the Nasdaq date (T if before 6:30pm EST otherwise T + 1) when getting EOD data from the Index",
    )


class Compression(Enum):
    NONE = "NONE"
    GZIP = "GZIP"


class LayoutType(Enum):
    SINGLE_FILE = "SINGLE_FILE"
    YEARLY_DIR_DAILY_FILE = "YEARLY_DIR_DAILY_FILE"


class DataCollectionsSpec(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    index_dc_subtype: StrictStr = Field(
        ..., description="Index Data Collection Subtype object key moves to array after transformation"
    )
    auto_persist: StrictBool = Field(
        False, description="Boolean to indicate whether to automatically persist the data. Default is false."
    )
    compression: Compression = Compression.GZIP
    date_col: StrictStr = "date"
    format: Literal["csv"] = "csv"
    layout_type: LayoutType = Field(
        LayoutType.SINGLE_FILE,
        description="SINGLE_FILE: one file. YEARLY_DIR_DAILY_FILE: one directory per year, each day, a file with YYYYMMDD format.",
    )
    location: StrictStr
    name: constr(pattern=r"^[A-Za-z0-9_]*$", min_length=3, max_length=128, strict=True)
    seed_file_path: Optional[StrictStr] = Field(None, description="Seed file for the data collection.")
    start_time: Optional[StrictStr] = None


class TimestampWindow(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    start_ts: Optional[constr(pattern=r"^(?:[01]\d|2[0-3]):(?:[0-5]\d):(?:[0-5]\d)$", strict=True)] = Field(
        None, description="the time of day of the deadline"
    )
    end_ts: constr(pattern=r"^(?:[01]\d|2[0-3]):(?:[0-5]\d):(?:[0-5]\d)$", strict=True) = Field(
        ..., description="the time of day of the deadline"
    )
    tzinfo: Optional[StrictStr] = Field(None, description="Timezone of the window")


class RealTimeTradeType(Enum):
    ELIGIBLE = "ELIGIBLE"
    INELIGIBLE = "INELIGIBLE"


class PortfolioUom(Enum):
    SHARES = "SHARES"
    WEIGHT = "WEIGHT"


class PortfolioStatus(Enum):
    PENDING_VALIDATION = "PENDING_VALIDATION"
    FAILED_VALIDATION = "FAILED_VALIDATION"
    PASSED_VALIDATION = "PASSED_VALIDATION"
    SELECTED = "SELECTED"
    UNSELECTED = "UNSELECTED"
    FINAL = "FINAL"
    DELETED = "DELETED"


class SecapiSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    custom_metric: Optional[StrictStr] = None


class MerqubeIndexSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    metric_name: Optional[StrictStr] = None


class FreezerConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    primary_index_name: Optional[StrictStr] = Field(None, description="the primary index to use underlying data from")
    prices: StrictBool = False
    rebalances: StrictBool = False
    corax: StrictBool = False
    fx_rates: StrictBool = False


class PositionIdentifierType(Enum):
    RIC = "RIC"
    CURRENCY_CODE = "CURRENCY_CODE"
    FSYM_ID = "FSYM_ID"
    TICKER = "TICKER"
    BBG_TICKER = "BBG_TICKER"
    CUSIP = "CUSIP"


class DayOfWeek(Enum):
    MON = "MON"
    TUE = "TUE"
    WED = "WED"
    THU = "THU"
    FRI = "FRI"


class AssetType(Enum):
    CASH = "CASH"
    THIRD_PARTY_INDEX = "THIRD_PARTY_INDEX"
    EQUITY = "EQUITY"
    OPTION = "OPTION"
    FUTURES = "FUTURES"
    MUTUAL_FUND = "MUTUAL_FUND"
    MERQUBE_INDEX = "MERQUBE_INDEX"
    CUSTOM_SECAPI_INDEX = "CUSTOM_SECAPI_INDEX"


class OptionStyle(Enum):
    AMERICAN = "AMERICAN"
    EUROPEAN = "EUROPEAN"


class OptionType(Enum):
    PUT = "PUT"
    CALL = "CALL"


class OptionExpirationType(Enum):
    AM = "AM"
    PM = "PM"


class TradeType(Enum):
    BUY = "BUY"
    SELL = "SELL"


class StrategyOptionStrikeType(Enum):
    PCT_SPOT = "PCT_SPOT"
    DELTA = "DELTA"
    INCOME = "INCOME"
    COSTLESS = "COSTLESS"


class StrategyOptionExpiryPeriodType(Enum):
    ANNUALLY = "ANNUALLY"
    QUARTERLY = "QUARTERLY"
    MONTHLY_3RD_FRIDAY = "MONTHLY_3RD_FRIDAY"
    WEEKLY = "WEEKLY"


class OptionStrategyType(Enum):
    COVERED_CALL = "COVERED_CALL"
    PUT_WRITE = "PUT_WRITE"
    PROTECTIVE_PUT = "PROTECTIVE_PUT"
    COLLAR = "COLLAR"
    CUSTOM = "CUSTOM"


class SecurityCreationResponse(BaseModel):
    id: Optional[StrictStr] = None
    inserts: Optional[int] = None


class DataType(Enum):
    string = "string"
    number64 = "number64"
    datetime64 = "datetime64"
    int64 = "int64"
    bool = "bool"
    object = "object"


class MetricsSchema(BaseModel):
    data_type: DataType
    description: StrictStr = Field(..., description="a description of what this metric represents")
    name: StrictStr = Field(..., description="metric name")
    object_schema: Optional[Dict[str, Any]] = Field(
        None,
        description="optional - this supports complex objects, ie you can specify the  metric is of this schema. THis allows you to upload a json schema itself of this metric. THis is for downstream users of this metric.",
    )


class IdentifierType1(Enum):
    RIC = "RIC"
    secapi_name = "secapi_name"


class Security(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identifier_type: IdentifierType1
    identifier_value: StrictStr = Field(..., examples=["AAPL.QQ"])
    security_type: StrictStr = Field(..., examples=["equity"])


class SecurityListPost(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(pattern=r"^[^!*\'() ;:@&=+$,/?%#\[\]]", strict=True) = Field(
        ..., description="unique name among all other security lists"
    )
    namespace: Optional[StrictStr] = None
    realtime: Optional[StrictBool] = None
    securities: List[Security]


class OptionResponse(BaseModel):
    price: Optional[float] = Field(None, description="Option Price")
    vol: Optional[float] = Field(None, description="Implied Volatility")
    interest_rate: Optional[float] = Field(None, description="Implied Interest Rate")
    dividend_yield: Optional[float] = Field(None, description="Implied Dividend Yield for the underlying")
    spot: Optional[float] = Field(None, description="Underlying spot price")
    delta: Optional[float] = Field(None, description="Delta of this option")
    theta: Optional[float] = Field(None, description="Theta of the option being priced")
    gamma: Optional[float] = Field(None, description="Gamma of the option being priced")
    vega: Optional[float] = Field(None, description="Vega of the option being priced")
    bid_ask_spread: Optional[float] = Field(
        None, description="Spread between Bid and Ask prices of the option being priced"
    )
    request_id: Optional[StrictStr] = Field(None, description="Request ID sent in the request")


class FindStrikeResponse(BaseModel):
    strike: Optional[float] = Field(None, description="Strike that prices to the given budget.")
    spot: Optional[float] = Field(None, description="Underlying spot price.")
    strike_percentage: Optional[float] = Field(
        None, description="Strike as a percentage of the underlying spot price that prices to the given budget."
    )
    request_id: Optional[StrictStr] = Field(None, description="Request ID sent in the request")


class DeadlineType(Enum):
    calculation = "calculation"
    restatement = "restatement"


class OgPriority(Enum):
    P1 = "P1"
    P2 = "P2"
    P3 = "P3"


class Deadline(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    time_of_day: constr(pattern=r"^(?:[01]\d|2[0-3]):(?:[0-5]\d):(?:[0-5]\d)$", strict=True) = Field(
        ..., description="the time of day of the deadline"
    )
    deadline_type: DeadlineType = DeadlineType.calculation
    next_day: StrictBool = Field(
        False,
        description="set this to true if the index starts running on day T but the deadline does not pass until T+1 in that index timezone",
    )
    og_priority: OgPriority = OgPriority.P1
    business_days_prior: int = Field(0, description="the amount of days before T to check for data existence")
    metrics: Optional[List[StrictStr]] = Field(
        None, description="the list of metrics to check in the deadline checker script"
    )


class MetricsArrItem(BaseModel):
    id: Optional[StrictStr] = Field(None, examples=["price_return"])
    value: Optional[float] = Field(None, examples=[1000.0000000000002])


class MetricsDef(BaseModel):
    name: Optional[StrictStr] = Field(None, examples=["daily_return"])
    type: Optional[StrictStr] = Field(None, examples=["double"])


class ErrorCodes(BaseModel):
    code: Optional[StrictStr] = None
    message: Optional[StrictStr] = None


class IntradayPublishConfigBloombergTargetParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    rounding_decimals: Optional[int] = None
    ticker: Optional[StrictStr] = None


class IntradayPublishConfigReutersTargetParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    rounding_decimals: Optional[int] = None
    ticker: Optional[StrictStr] = None
    post_type: Optional[ReutersProviderKwargsPostType] = None


class RunStateStatus(Enum):
    PENDING_CREATION = "PENDING_CREATION"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    RUNNING = "RUNNING"


class Ticker(Enum):
    NDX = "NDX"
    SPX = "SPX"
    RUT = "RUT"
    MQ5C = "MQ5C"


class IndexTicker(BaseModel):
    ticker: Ticker


class ClientBaseVal(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    base_date: constr(pattern=r"^[0-9]{4}[-/][0-9]{2}[-/][0-9]{2}", strict=True) = Field(
        ..., description="the date that the index has level 'base_value'", examples=["2000-01-04"]
    )
    base_value: PositiveFloat = Field(
        ..., description="set the index value on base_date to this base_value", examples=[1000.0]
    )


class ClientIndexBaseProperties(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bbg_ticker: Optional[StrictStr] = Field(
        None,
        description="due to the limitations of the Bloomberg ticker creation process (no API), this must be a pre-created ticker. You can email MerQube a list of tickers to create on your behalf at support@merqube.com. Then, you provide those as input to these indices",
        examples=["MY_TICKER"],
    )
    description: StrictStr = Field(
        ...,
        description="set to the description of the index, which will show on merqube.com",
        examples=["My Index Description"],
    )
    email_list: List[StrictStr] = Field(
        default_factory=list,
        description="list of emails to send daily dissemination reports, and the initial backtest reports, to; if not specified, no emails will be sent",
        examples=[["bob@mycompany.com", "alice@mycompany.com"]],
    )
    name: constr(pattern=r"^[^!*\'() ;:@&=+$,/?%#\[\]]", strict=True) = Field(
        ...,
        description="set to the name of the index. Commonly people use the ticker as the name, but that is not necessary. Must be globally unique - you will get a 409 if this index name is taken ",
        examples=["My Index"],
    )
    namespace: StrictStr = Field(..., description="set to the namespace of the index", examples=["mycompany"])
    title: StrictStr = Field(
        ..., description="set to the title of the index that shows up on merqube.com", examples=["My Index Title"]
    )


class ClientIndexConfigBase(ClientBaseVal, ClientIndexBaseProperties):
    pass


class ReinvestmentTime(Enum):
    AT_OPEN = "AT_OPEN"
    AT_CLOSE = "AT_CLOSE"


class ReinvestmentType(Enum):
    INDEX = "INDEX"
    SECURITY = "SECURITY"


class Method(Enum):
    FIXED_WEIGHT = "FIXED_WEIGHT"
    EQUAL_WEIGHT = "EQUAL_WEIGHT"


class RebalanceTypeWithNoConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    method: Method


class FreeFloatRebalanceConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    method: Literal["FREE_FLOAT"] = "FREE_FLOAT"
    max_weight: Optional[float] = None


class Day(Enum):
    Monday = "Monday"
    Tuesday = "Tuesday"
    Wednesday = "Wednesday"
    Thursday = "Thursday"
    Friday = "Friday"


class WeeklyRebalanceDates(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    day: Day


class WeeklyRebalanceDateConfig(WeeklyRebalanceDates):
    model_config = ConfigDict(
        extra="forbid",
    )
    frequency: Literal["WEEKLY"] = "WEEKLY"
    roll_forward: StrictBool = True


class StartingMonth(Enum):
    January = "January"
    February = "February"
    March = "March"
    April = "April"
    May = "May"
    June = "June"
    July = "July"
    August = "August"
    September = "September"
    October = "October"
    November = "November"
    December = "December"


class InitialMonthConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    roll_forward: StrictBool = True
    frequency: constr(pattern=r"^(ANNUAL|QUARTERLY|SEMIANNUAL|MONTHLY)$", strict=True)
    starting_month: Optional[StartingMonth] = None


class Method1(Enum):
    FIRST_BUSINESS_DAY = "FIRST BUSINESS DAY"
    LAST_BUSINESS_DAY = "LAST BUSINESS DAY"


class SimpleRebalanceDateConfigOptions(InitialMonthConfig):
    model_config = ConfigDict(
        extra="forbid",
    )
    method: Method1


class XthDayRebalanceDateConfig(InitialMonthConfig):
    model_config = ConfigDict(
        extra="forbid",
    )
    method: Literal["XTH CALENDAR DAY"]
    xth_day: Optional[conint(ge=1, le=31)] = None


class XthWeek(Enum):
    First = "First"
    Second = "Second"
    Third = "Third"
    Fourth = "Fourth"
    Last = "Last"


class AdvancedRebalanceDateConfig(InitialMonthConfig, WeeklyRebalanceDates):
    model_config = ConfigDict(
        extra="forbid",
    )
    method: Literal["ADVANCED"] = "ADVANCED"
    xth_week: XthWeek
    roll_forward: StrictBool = True
    day: Day


class CalendarAlias(Enum):
    default = "default"
    Canada = "Canada"
    Euronext_Paris = "Euronext Paris"
    Europe = "Europe"
    US = "US"
    Transatlantic = "Transatlantic"


class LegacyStaticBasketCalendarConfig(BaseModel):
    calendar_identifiers: List[CalendarAlias]
    holidays_to_add: Optional[List[constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True)]] = None
    holidays_to_remove: Optional[List[constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True)]] = None


class StaticBasketCalendarConfig(BaseModel):
    swaps_monitor_codes: List[StrictStr]
    holidays_to_add: Optional[List[constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True)]] = None
    holidays_to_remove: Optional[List[constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True)]] = None


class ReturnType(Enum):
    total_return = "total_return"
    price_return = "price_return"
    net_total_return = "net_total_return"


class Constituent(BaseModel):
    identifier: StrictStr = Field(..., title="Identifier")
    identifier_type: PositionIdentifierType
    amount: Optional[confloat(ge=0.0, le=100.0)] = None


class SelectionDates(Enum):
    rebalance_date = "rebalance_date"
    prev_month = "prev_month"
    prev_week = "prev_week"


class RebalanceConfig(BaseModel):
    rebalance_method: Union[FreeFloatRebalanceConfig, RebalanceTypeWithNoConfig]
    rebalance_dates: Union[
        WeeklyRebalanceDateConfig,
        AdvancedRebalanceDateConfig,
        SimpleRebalanceDateConfigOptions,
        XthDayRebalanceDateConfig,
    ]
    selection_dates: SelectionDates


class ClientSSTRSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ric: StrictStr = Field(..., description="set to the RIC of the underlying equity", examples=["LMVH.PA"])
    reinvestment_type: ReinvestmentTime = ReinvestmentTime.AT_OPEN


class FeeType(Enum):
    fixed = "fixed"
    percentage_pre = "percentage_pre"
    percentage_post = "percentage_post"
    fixed_points_underlying = "fixed_points_underlying"


class ClientDecrementUnderlyingIDType(Enum):
    RIC = "RIC"
    MERQUBE_INDEX = "MERQUBE_INDEX"


class ClientDecrementUnderlying(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identifier_type: ClientDecrementUnderlyingIDType
    identifier: StrictStr = Field(..., examples=["COST.OQ"])


class LevelOverride(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True) = Field(..., examples=["2000-01-04"])
    level: float
    comment: Optional[StrictStr] = None


class ReinvestDividendType(Enum):
    INDEX = "INDEX"
    SECURITY = "SECURITY"
    CASH = "CASH"


class ReinvestDay(Enum):
    AT_OPEN = "AT_OPEN"
    AT_CLOSE = "AT_CLOSE"


class ClientEBCoraxConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    reinvest_dividends: StrictBool = Field(True, examples=[False])
    reinvest_dividend_type: Optional[ReinvestDividendType] = None
    deduct_tax: StrictBool = False
    reinvest_day: ReinvestDay = ReinvestDay.AT_OPEN


class Destination(Enum):
    BLOOMBERG = "BLOOMBERG"
    REFINITIV = "REFINITIV"
    MORNINGSTAR = "MORNINGSTAR"
    FACTSET = "FACTSET"


class DisseminationSetting(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    destination: Destination
    ticker: StrictStr


class TickConfiguration(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    intraday_timezone: StrictStr = Field("US/Eastern", examples=["US/Eastern"])
    tick_start_hour: Optional[conint(ge=0, le=23)] = Field(
        None, description="hour the index will start ticking intraday"
    )
    tick_start_minute: Optional[conint(ge=0, le=59)] = Field(
        None, description="minute the index will start ticking intraday"
    )
    tick_end_hour: Optional[conint(ge=0, le=23)] = Field(None, description="hour the index will end ticking intraday")
    tick_end_minute: Optional[conint(ge=0, le=59)] = Field(
        None, description="minute the index will end ticking intraday"
    )


class ClientRuntimeInfo(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    run_hour: int = Field(
        ..., description="set to the hour of day to run the index in the index's timezone", examples=[16]
    )
    run_minute: int = Field(..., description="set to the minute of the hour to run the index ", examples=[30])
    timezone: StrictStr = Field("US/Eastern", description="set to the timezone of the index", examples=["US/Eastern"])


class Root(Enum):
    SPY = "SPY"
    QQQ = "QQQ"
    IWM = "IWM"
    EFA = "EFA"
    EEM = "EEM"
    TLT = "TLT"
    LQD = "LQD"
    HYG = "HYG"
    GLD = "GLD"


class ClientBufferSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    protection_start: confloat(ge=0.0, le=100.0) = Field(
        ...,
        description="losses on the underlying are incurred up to protection_start, the portfolio is protected against losses between protection_start and protection_end, and then losses after protection_end are also incurred. These are represented as percentages of the underlying. Eg on start=95 and end=70 (sometimes a called a 5/30 buffer), the first 5% of losses are incurred, the portfolio is protected between -5% and -30%, then losses after 30% are added to 5% and are incurred. In this example, if the underlying drops 32%, the index will lose 7%.",
        examples=[95.0],
    )
    protection_end: confloat(ge=0.0, le=100.0) = Field(
        ..., description="eg the 30 in the above example. Must be < protection_start.", examples=[70.0]
    )
    roll_freq: conint(ge=1) = Field(12, description="frequency in months of the options roll", examples=[3])
    root: Root = Field(..., description="the root of the options", examples=["SPY"])


class OptionRoot(Enum):
    SPY = "SPY"
    QQQ = "QQQ"
    IWM = "IWM"
    EFA = "EFA"
    EEM = "EEM"
    TLT = "TLT"
    LQD = "LQD"
    HYG = "HYG"
    GLD = "GLD"


class RebalancingStrategy(Enum):
    weekly_Monday = "weekly_Monday"
    weekly_Tuesday = "weekly_Tuesday"
    weekly_Wednesday = "weekly_Wednesday"
    weekly_Thursday = "weekly_Thursday"
    weekly_Friday = "weekly_Friday"
    monthly_End_Of_Month = "monthly_End_Of_Month"
    monthly_3rd_Friday = "monthly_3rd_Friday"


class ClientSingleOptionBase(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    rebalancing_strategy: RebalancingStrategy = Field(..., description="the rebalancing schedule")
    root: OptionRoot = Field(
        OptionRoot.SPY,
        description="the root of the option; more roots may be supported in the future",
        examples=["SPY"],
    )
    option_underlying: Optional[OptionRoot] = Field(
        None,
        description="the underlying option to use; if not specified the default is to use the `root`",
        examples=["SPY"],
    )
    exposure: confloat(ge=0.0) = Field(..., description="percentage of the underlying you want exposure to")


class ConstantInterestRateConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    rate: float
    type: Literal["constant"]


class ReferenceRate(Enum):
    SOFR = "SOFR"
    EFFR = "EFFR"


class VariableInterestRateConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    reference_rate: ReferenceRate
    spread: float
    is_constant: StrictBool = Field(
        False,
        description="Used to determine if the rate value is to be set once per rebalance period or changed every day",
    )
    type: Literal["variable"]


class ClientCoveredStrike(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    options: confloat(ge=0.0)
    method: Literal["Covered"] = Field("Covered", examples=["Covered"])
    options_method: Literal["Strike"] = Field("Strike", examples=["Strike"])


class ClientCoveredDelta(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    options: confloat(ge=0.0, le=100.0)
    method: Literal["Covered"] = Field("Covered", examples=["Covered"])
    options_method: Literal["Delta"] = Field("Delta", examples=["Delta"])


class ClientDownsideStrike(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    options: confloat(ge=0.0)
    method: Literal["Downside"] = Field("Downside", examples=["Downside"])
    options_method: Literal["Strike"] = Field("Strike", examples=["Strike"])


class ClientDownsideDelta(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    options: confloat(ge=-100.0, le=0.0)
    method: Literal["Downside"] = Field("Downside", examples=["Downside"])
    options_method: Literal["Delta"] = Field("Delta", examples=["Delta"])


class OptionExerciseStyle(Enum):
    EUROPEAN = "EUROPEAN"
    AMERICAN = "AMERICAN"


class ClientStrategyOptionExpiry(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiry_period_type: StrategyOptionExpiryPeriodType
    time_period_away: conint(ge=1)
    day_of_week: Optional[DayOfWeek] = Field(None, description="Should only be set if expiry_time_period is WEEKLY")


class EarlyExerciseTreatment(Enum):
    KEEP_IN_CASH = "KEEP_IN_CASH"
    RESTRIKE_AT_EXPIRY = "RESTRIKE_AT_EXPIRY"
    RESTRIKE_AT_DAYS = "RESTRIKE_AT_DAYS"


class ClientStrategyOptionEarlyExercise(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    enabled: StrictBool = False
    treatment: Optional[EarlyExerciseTreatment] = None
    restrike_days: Optional[conint(ge=1)] = None
    borrowing_rate: Optional[confloat(ge=0.0)] = None


class ClientStrategyOptionRebalanceRelativeToExpiry(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    schedule_type: Literal["REL_TO_EXPIRY"]
    days_before_expiry: conint(ge=0)
    roll_back: StrictBool = Field(..., description="Whether or not to roll back or roll forward if date is a holiday")


class ClientStrategyOptionRebalanceCertainDay(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    schedule_type: Literal["CERTAIN_DAY"]
    time_period_away: conint(ge=1)
    day_of_week: DayOfWeek
    week_of_month: Optional[conint(ge=1, le=4)] = None
    roll_back: StrictBool = Field(..., description="Whether or not to roll back or roll forward if date is a holiday")


class ClientSingleOptionConfig(ClientSingleOptionBase, ClientRuntimeInfo, ClientIndexConfigBase):
    model_config = ConfigDict(
        extra="forbid",
    )
    strategy: Union[ClientCoveredStrike, ClientCoveredDelta, ClientDownsideStrike, ClientDownsideDelta]


class ClientBufferConfig(ClientBufferSpecific, ClientRuntimeInfo, ClientIndexConfigBase):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class IncludeOrExclude(Enum):
    IN = "IN"
    NOT_IN = "NOT_IN"


class CountryOfDomicileFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["country_of_domicile"]
    domicile_countries: List[StrictStr]
    include_or_exclude: IncludeOrExclude = Field(
        ..., description="Whether to include or exclude the specified countries"
    )


class CountryOfExchangeFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["country_of_exchange"]
    exchange_countries: List[StrictStr]
    include_or_exclude: IncludeOrExclude = Field(
        ..., description="Whether to include or exclude the specified countries"
    )


class MicFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["mic"]
    mics: List[StrictStr]
    include_or_exclude: IncludeOrExclude = Field(
        ..., description="Whether to include or exclude the specified MIC codes"
    )


class SectorFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["sector"]
    sectors: List[StrictStr]
    include_or_exclude: IncludeOrExclude = Field(..., description="Whether to include or exclude the specified sectors")


class SubSectorFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["sub_sector"]
    sub_sectors: List[StrictStr]
    include_or_exclude: IncludeOrExclude = Field(
        ..., description="Whether to include or exclude the specified sub-sectors"
    )


class TRBCFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["trbc"]
    trbc_codes: List[float] = Field(..., description="TRBC codes to filter by")
    include_or_exclude: IncludeOrExclude = Field(
        ..., description="Whether to include or exclude the specified TRBC codes"
    )


class MktCapType(Enum):
    total_mkt_cap = "total_mkt_cap"
    float_mkt_cap = "float_mkt_cap"


class MarketCapFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["market_cap"]
    currency: StrictStr
    mkt_cap_type: MktCapType
    threshold_retention_min: Optional[float] = None
    threshold_retention_max: Optional[float] = None
    threshold_addition_min: Optional[float] = None
    threshold_addition_max: Optional[float] = None


class Advt3mFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["advt_3m"]
    currency: StrictStr
    threshold_retention_min: Optional[float] = None
    threshold_retention_max: Optional[float] = None
    threshold_addition_min: Optional[float] = None
    threshold_addition_max: Optional[float] = None


class MarketCapPercentFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["mkt_cap_percent"]
    mkt_cap_type: MktCapType
    threshold_retention_min: Optional[float] = None
    threshold_retention_max: Optional[float] = None
    threshold_addition_min: Optional[float] = None
    threshold_addition_max: Optional[float] = None


class ListingWeightCap(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fsym_id: Any
    country: StrictStr
    weight_cap: float


class WeightingStrategy(Enum):
    equal_weight = "equal_weight"
    total_mkt_cap = "total_mkt_cap"
    float_mkt_cap = "float_mkt_cap"
    fixed = "fixed"
    advt_3m = "advt_3m"


class WeightingSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    weighting_strategy: WeightingStrategy
    listing_weight_cap: Optional[float] = Field(
        None, description="The overall weight cap for the allocation unit, if applicable"
    )
    specific_listing_weight_caps: Optional[List[ListingWeightCap]] = None


class StaticListingDefinition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fsym_id: StrictStr
    country: StrictStr
    fixed_weight: Optional[float] = Field(
        None, description="The fixed weight for the listing in the allocation unit, if applicable"
    )


class AllocationType(Enum):
    mkt_cap_sorted = "mkt_cap_sorted"
    parent_universe = "parent_universe"
    static = "static"


class NotificationConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    emails: Optional[List[StrictStr]] = None
    email_list_uuid: Optional[StrictStr] = None
    enabled: Optional[StrictBool] = None


class ClientDefinedOutcomeScheduleType(Enum):
    CERTAIN_DAY = "CERTAIN_DAY"
    MONTH_END = "MONTH_END"
    THIRD_FRIDAY = "THIRD_FRIDAY"


class ClientDefinedOutcomeExpiryPeriodType(Enum):
    MONTHS = "MONTHS"
    WEEKS = "WEEKS"


class ClientDefinedOutcomeRebalancer(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    roll_back: StrictBool
    schedule_type: ClientDefinedOutcomeScheduleType
    day_of_week: Optional[DayOfWeek] = None
    week_of_month: Optional[conint(ge=1, le=5)] = None
    time_period_away: conint(ge=0)
    days_before_expiry: Optional[conint(ge=0)] = None


class ClientDefinedOutcomeExpiry(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiry_period_type: ClientDefinedOutcomeExpiryPeriodType
    expiry_period_value: confloat(ge=0.0)


class ClientDefinedOutcomeOptionType(Enum):
    PUT = "PUT"
    CALL = "CALL"


class ClientDefinedOutcomeTradeType(Enum):
    BUY = "BUY"
    SELL = "SELL"


class ClientDefinedOutcomeStrikeType(Enum):
    DELTA = "DELTA"
    PCT_SPOT = "PCT_SPOT"


class ClientDefinedOutcomeRoots(Enum):
    SPY = "SPY"
    QQQ = "QQQ"
    IWM = "IWM"
    EFA = "EFA"
    XIU = "XIU"
    TLT = "TLT"
    HYG = "HYG"
    EEM = "EEM"
    LQD = "LQD"
    VOO = "VOO"
    IVV = "IVV"
    SPX = "SPX"
    VTWO = "VTWO"
    BITO = "BITO"
    IBIT = "IBIT"
    MSFT = "MSFT"
    AMZN = "AMZN"
    TSLA = "TSLA"
    META = "META"
    AAPL = "AAPL"
    NVDA = "NVDA"
    GOOGL = "GOOGL"
    GOOG = "GOOG"


class ClientDefinedOutcomeOption(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    strike_type: ClientDefinedOutcomeStrikeType
    option_type: ClientDefinedOutcomeOptionType
    trade_type: ClientDefinedOutcomeTradeType
    strike_value: confloat(ge=0.0)
    root: ClientDefinedOutcomeRoots
    exercise_style: OptionExerciseStyle
    exposure: Optional[confloat(ge=0.0)] = None


class ClientDefinedOutcomeParticipationRateStrategyOption(ClientDefinedOutcomeOption):
    model_config = ConfigDict(
        extra="forbid",
    )
    exercise_style: OptionExerciseStyle
    exposure: confloat(ge=0.0)
    option_type: ClientDefinedOutcomeOptionType


class ClientDefinedOutcomeParticipationRateStrategy(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    strategy: Literal["PARTICIPATION_RATE"]
    max_participation: confloat(ge=0.0) = 200
    option: ClientDefinedOutcomeParticipationRateStrategyOption


class ClientDefinedOutComeNoEtfStrategy(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    strategy: Literal["NO_ETF"]
    min_cap: confloat(ge=0.0) = 0


class OptionsUnderlierItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: StrictStr


class OptionsUnderlierGet(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    allowed_underliers: List[OptionsUnderlierItem]


class Status(BaseModel):
    created_at: Optional[StrictStr] = None
    created_by: Optional[StrictStr] = None
    last_modified: StrictStr
    last_modified_by: Optional[StrictStr] = None
    locked_after: Optional[datetime] = Field(
        None,
        description="If this is set (non null), the manifest is locked for all edits to any other field after this timestamp. A PUT/PATCH may be used to first unlock the manifest, by setting this field (to a max of one hour in the future), or to `null` again, to make other edits.",
    )


class CalendarIdentifiers(BaseModel):
    calendar_identifiers: Optional[List[constr(pattern=r"^(FUT|MIC|FX|SM|MQI|OVERLAY):.+$", strict=True)]] = None


class HolidaysToAdd(BaseModel):
    holidays_to_add: Optional[List[date]] = None


class Operator(Enum):
    union = "union"
    intersection = "intersection"
    difference = "difference"


class WeekmaskEnum(Enum):
    Mon = "Mon"
    Tue = "Tue"
    Wed = "Wed"
    Thu = "Thu"
    Fri = "Fri"
    Sat = "Sat"
    Sun = "Sun"


class NestedCalendarSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operator: Operator
    weekmask: Optional[List[WeekmaskEnum]] = None
    children: List[Union[CalendarIdentifiers, HolidaysToAdd, NestedCalendarSchema]]


class Condition(Enum):
    any = "any"
    all = "all"
    custom = "custom"


class FlatCalendarSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    calendar_identifiers: List[constr(pattern=r"^(FUT|MIC|FX|SM|MQI|OVERLAY):.+$", strict=True)] = Field(
        default_factory=list
    )
    swaps_monitor_codes: List[constr(pattern=r"^[a-zA-Z]{3}$", strict=True)] = Field(default_factory=list)
    condition: Condition = Condition.all
    holidays_to_add: List[date] = Field(default_factory=list)
    holidays_to_remove: List[date] = Field(default_factory=list)
    weekmask: List[WeekmaskEnum] = Field(
        [WeekmaskEnum.Mon, WeekmaskEnum.Tue, WeekmaskEnum.Wed, WeekmaskEnum.Thu, WeekmaskEnum.Fri],
        description="weekmask of valid business days",
    )


class PodKwargs(BaseModel):
    name: Optional[StrictStr] = None


class SubPod(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    arguments: Optional[List[List[StrictStr]]] = None
    command: StrictStr
    pod_type: StrictStr
    uuid: StrictStr
    env_vars: Optional[List[List[StrictStr]]] = None
    pod_kwargs: Optional[PodKwargs] = None


class S3Bucket(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bucket: StrictStr
    path: Optional[StrictStr] = None


class AirflowConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    description: Optional[StrictStr] = Field(None, description="A short description related with the generated runner")
    s3_location: Optional[S3Bucket] = Field(
        None,
        description="Bucket and path where the generated dag should be stored. If not defined `merq-airflow-dags-airflow2` is defined in merqutil",
    )
    dag: Optional[Dict[str, Any]] = Field(None, description="use this to set kwargs for the dag")
    pod: Optional[Dict[str, Any]] = Field(None, description="use this to set kwargs for the pod")
    env: Optional[Dict[str, Any]] = Field(None, description="use this to set ENV variables in the pod")
    subpods: Optional[List[SubPod]] = None


class EmailDissapiConfig(BaseModel):
    recipient_list: List[StrictStr] = Field(..., min_length=1)
    email_list: Optional[List[StrictStr]] = None
    bcc_list: Optional[List[StrictStr]] = None
    cc_list: Optional[List[StrictStr]] = None
    subject: StrictStr
    content: Optional[StrictStr] = None
    file_keys: Optional[List[StrictStr]] = None


class SftpDissapiConfig(BaseModel):
    sftp_ids: List[StrictStr]
    file_keys: List[StrictStr]


class S3DissapiConfig(BaseModel):
    bucket: StrictStr
    key_prefix: StrictStr
    file_keys: List[StrictStr]


class DisseminationDestinations(BaseModel):
    email_dissapi_configs: Optional[List[EmailDissapiConfig]] = Field(None, min_length=1)
    sftp_dissapi_configs: Optional[List[SftpDissapiConfig]] = None
    s3_dissapi_configs: Optional[List[S3DissapiConfig]] = None


class IndexReport(BaseModel):
    uuid: StrictStr
    program_args: Optional[Dict[str, Any]] = None
    task_id: Optional[StrictStr] = None
    dissemination_destinations: Optional[DisseminationDestinations] = None


class AlertPriority(Enum):
    P1 = "P1"
    P2 = "P2"
    P3 = "P3"
    P4 = "P4"
    P5 = "P5"


class RunConfigLabelAdditional(BaseModel):
    label: StrictStr = Field(..., description="unique label of this rc")


class HolidayCalendar(BaseModel):
    cal_type: Optional[StrictStr] = Field(None, examples=["MIC"])
    mic: Optional[StrictStr] = Field(None, examples=["XNYS"])


class Schedule(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    retries: int
    retry_interval_min: int
    schedule_start: StrictStr
    schedule_cron: Optional[StrictStr] = None
    timeout_delta: Optional[StrictStr] = Field(None, examples=["minutes=17"])
    business_days_prior: Optional[int] = Field(None, examples=[1])
    holiday_calendar: Optional[HolidayCalendar] = None
    triggers: Optional[List[StrictStr]] = Field(
        None,
        description="the dataset trigger to which the dag subscribes to. This is a list of trigger(s)",
        examples=[["trigger://exchange/XNYS/early_closing.merq"]],
    )


class CopyFromManifest(BaseModel):
    copy_from_uuid: StrictStr = Field(..., description="the uuid of the resource to start from")
    field_deletes: Optional[List[StrictStr]] = Field(None, description="fields to delete from the from-manifest")
    field_updates: Optional[Dict[str, Any]] = Field(
        None,
        description="a dictionary of top level keys that the original manifest will be updated with (ie `manifest.update(this[field_updates])`. Top level keys can be added or replaced. To change the namespace, add namespace to the field_updates dict. The new manifest must be valid per the original resource definition.",
    )
    name: StrictStr = Field(..., description="the name of the new resource")


class CrudExtra(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: StrictStr
    namespace: StrictStr
    status: Status


class CountryCode(Enum):
    AE = "AE"
    AR = "AR"
    AT = "AT"
    AU = "AU"
    BD = "BD"
    BE = "BE"
    BG = "BG"
    BH = "BH"
    BR = "BR"
    BW = "BW"
    CA = "CA"
    CH = "CH"
    CI = "CI"
    CL = "CL"
    CN = "CN"
    CO = "CO"
    CY = "CY"
    CZ = "CZ"
    DE = "DE"
    DK = "DK"
    EC = "EC"
    EG = "EG"
    ES = "ES"
    FI = "FI"
    FR = "FR"
    GB = "GB"
    GR = "GR"
    HK = "HK"
    HR = "HR"
    HU = "HU"
    ID = "ID"
    IE = "IE"
    IL = "IL"
    IN = "IN"
    IS = "IS"
    IT = "IT"
    JP = "JP"
    KH = "KH"
    KR = "KR"
    KW = "KW"
    LK = "LK"
    LU = "LU"
    MX = "MX"
    MY = "MY"
    NL = "NL"
    False_ = False
    NZ = "NZ"
    PE = "PE"
    PH = "PH"
    PK = "PK"
    PL = "PL"
    PT = "PT"
    QA = "QA"
    RU = "RU"
    SA = "SA"
    SE = "SE"
    SG = "SG"
    SI = "SI"
    SK = "SK"
    TH = "TH"
    TN = "TN"
    TR = "TR"
    TT = "TT"
    TW = "TW"
    US = "US"
    VN = "VN"
    ZA = "ZA"
    ZM = "ZM"


class Administrative(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    role: Role
    deadlines: Optional[List[Deadline]] = None
    client: Optional[Client] = None


class Webpage(BaseModel):
    custom_charts: Optional[List[CustomCharts]] = None
    visible: StrictBool = True


class IdentifierUUIDPost(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    display_name: Optional[StrictStr] = None
    index_name: StrictStr
    metric: Optional[StrictStr] = None
    name: constr(pattern=r"^[^!*\'() ;:@&=+$,/?%#\[\]]", strict=True) = Field(
        ..., description="unique name among all other Identifiers of the provider resource type."
    )
    namespace: Optional[StrictStr] = None
    rounding_decimals: Optional[int] = None
    provider_kwargs: Optional[
        Union[BloombergProviderKwargs, ReutersProviderKwargs, SecapiProviderKwargs, NasdaqProviderKwargs]
    ] = None
    start_date: Optional[date] = None
    ticker: StrictStr
    num_days: Optional[conint(ge=0)] = Field(None, description="Number of days to disseminate data for")


class IdentifierUUIDPatchPutGet(IdentifierUUIDPost, CrudExtra):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class IndexIdentifierUUIDPost(IdentifierUUIDPost):
    model_config = ConfigDict(
        extra="forbid",
    )
    enabled: StrictBool = Field(
        True, description="Determines if the index will disseminate data based to this provider, default is true"
    )


class IdentifierUUIDRef(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: StrictStr
    provider: Provider
    enabled: StrictBool = Field(
        True, description="Determines if the index will disseminate data based on this Identifier"
    )


class ListDataCollections(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    data_collection: List[DataCollectionsSpec] = Field(default_factory=list)


class BasketPortfolioPatchIn(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    status: Optional[PortfolioStatus] = None
    status_change_reason: Optional[StrictStr] = None


class TargetPortfolioHandlerNotificationConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    diss_destinations: Optional[DisseminationDestinations] = None
    file_name_format: Optional[StrictStr] = None


class BasketPosition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: float = Field(..., title="Amount")
    asset_type: AssetType
    identifier: StrictStr = Field(..., title="Identifier")
    identifier_type: PositionIdentifierType
    position_id: Optional[StrictStr] = Field(None, examples=["1"], title="Position Id")


class DatedBasketPosition(BasketPosition):
    date: constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True) = Field(..., examples=["2000-01-04"])
    selection_date: Optional[constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True)] = Field(
        None, examples=["2000-01-04"]
    )


class RicSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identifier_type: Optional[PositionIdentifierType] = None
    real_time_trade_types: Optional[List[RealTimeTradeType]] = None
    use_primary_listing: StrictBool = Field(
        False,
        description="use the security's primary listing rather than the one from the identifier",
        title="Use Primary Listing",
    )


class FsymSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    country_code: CountryCode


class OptionSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identifier: Optional[StrictStr] = Field(None, title="Identifier")
    identifier_type: Optional[PositionIdentifierType] = None
    expiration_date: constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True) = Field(
        ..., examples=["2000-01-04"], title="Expiration Date"
    )
    type: OptionType = Field(..., title="Type")
    style: Optional[OptionStyle] = Field(None, title="Style")
    strike: float = Field(..., title="Strike Price")
    underlying: StrictStr = Field(..., title="Underlying Symbol")
    expiration_type: Optional[OptionExpirationType] = Field(None, title="Expiration Type")
    amount: float = Field(..., title="Amount of Shares")
    currency: StrictStr = Field("USD", title="Currency")
    lag: Optional[constr(pattern=r"^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}:\d{2}(\.\d{6})?$", strict=True)] = Field(
        None, examples=["2022-01-02T01:02:03"], title="Option Lag"
    )
    delta_hedge_flag: Optional[StrictBool] = None
    vol_multiplier: Optional[float] = None
    structure_id: Optional[confloat(ge=0.0)] = None
    leg_multiple: Optional[float] = None


class FuturesSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identifier: Optional[StrictStr] = Field(None, title="Identifier")
    identifier_type: Optional[PositionIdentifierType] = None
    expiration_date: Optional[constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True)] = Field(
        None, examples=["2000-01-04"], title="Expiration Date"
    )
    underlying: StrictStr = Field(..., title="Underlying Symbol")
    amount: float = Field(..., title="Amount of Shares")
    currency: StrictStr = Field("USD", title="Currency")
    lag: Optional[constr(pattern=r"^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}:\d{2}(\.\d{6})?$", strict=True)] = Field(
        None, examples=["2022-01-02T01:02:03"], title="Futures Lag"
    )


class RicEquityPosition(BasketPosition, RicSpecific):
    pass


class DatedRicEquityPosition(DatedBasketPosition, RicSpecific):
    pass


class FsymEquityPosition(BasketPosition, FsymSpecific):
    pass


class DatedFsymEquityPosition(DatedBasketPosition, FsymSpecific):
    pass


class OptionPosition(OptionSpecific, BasketPosition):
    pass


class FuturesPosition(FuturesSpecific, BasketPosition):
    pass


class SecapiBasketPosition(BasketPosition, SecapiSpecific):
    pass


class MerqubeIndexPosition(BasketPosition, MerqubeIndexSpecific):
    pass


class NewSecurity(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(pattern=r"^[^!*\'() ;:@&=+$,/?%#\[\]]", strict=True)
    namespace: StrictStr = Field(
        ...,
        description="the calling user must have permission to this namespace to create the security in this namespace",
    )
    eff_ts: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(
        None,
        description="DEPRECATED: this is no longer used for security creates, but allowed for backwards compatibility",
        examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]],
    )
    prov_ts: Union[
        datetime,
        date,
        constr(
            pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1,6})?$", strict=True
        ),
    ] = Field(..., examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]])
    source: Optional[StrictStr] = None


class SecurityMetrics(BaseModel):
    eff_ts: Union[
        datetime,
        date,
        constr(
            pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1,6})?$", strict=True
        ),
    ] = Field(..., examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]])
    id: StrictStr = Field(..., examples=["0000699a-fcd7-45d4-8ce4-064a4ffeced0"])
    metric: StrictStr = Field(..., examples=["Level"])
    source: Optional[StrictStr] = Field(None, examples=["some_gcp_feed"])
    lineage: Optional[Dict[str, Any]] = Field(None, description="data lineage information, for MerQube use only.")
    prov_ts: Union[
        datetime,
        date,
        constr(
            pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1,6})?$", strict=True
        ),
    ] = Field(..., examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]])
    value: Union[StrictStr, float, int, StrictBool, List, Dict[str, Any]]


class SecurityMetricsDeletion(BaseModel):
    eff_ts: Union[
        datetime,
        date,
        constr(
            pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1,6})?$", strict=True
        ),
    ] = Field(..., examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]])
    id: StrictStr = Field(..., examples=["0000699a-fcd7-45d4-8ce4-064a4ffeced0"])
    metric: StrictStr = Field(..., examples=["Level"])
    prov_ts: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]])
    source: Optional[StrictStr] = Field(None, examples=["some_gcp_feed"])


class SecurityListPatchPutGet(SecurityListPost, CrudExtra):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class Metrics(BaseModel):
    ts: Optional[datetime] = Field(None, description="iso8601 format")
    metrics: Optional[List[MetricsArrItem]] = None


class Stats(BaseModel):
    annual_volatility: Optional[float] = Field(None, examples=[3.717606464173326])
    annualized_return: Optional[float] = Field(None, examples=[6.665050717276233])
    cumulative_return: Optional[float] = Field(None, examples=[2.7597506251556547])
    id: Optional[StrictStr] = Field(None, examples=["YTD"])
    max_drawdown: Optional[float] = Field(None, examples=[-1.3877029296510448])
    sharpe_ratio: Optional[float] = Field(None, examples=[1.759543308780235])
    start_date: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]])
    end_date: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]])


class IntradayTickFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    start_date: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]])
    end_date: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, examples=[["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"]])
    start_time: Optional[StrictStr] = Field(
        None,
        description="Inclusive start time of the day to start running this intraday index. Format is %H:%M:%S.%f. This should be in the timezone of the index based on tzinfo.",
        examples=[74340.262345],
    )
    end_time: Optional[StrictStr] = Field(
        None,
        description="Inclusive end time of the day to stop running this intraday index. Format is %H:%M:%S.%f. This should be in the timezone of the index based on tzinfo.",
        examples=[74340.262345],
    )
    days_of_week: Optional[List[int]] = Field(
        None,
        description="Which days of the week to run the index. Each day of the week is denoted by an integer with Monday = 0 and Sunday = 6",
    )
    exclude_holidays: Optional[StrictBool] = Field(
        None,
        description="If this is true use the index holiday calendar to decide which days to run the index. It will only run on non-holidays.",
    )


class IntradayPublishConfigTargetBase(BaseModel):
    active_time_ranges: Optional[List[IntradayTickFilter]] = Field(
        None,
        description="Time ranges during which values should be published to this target. Target level active_time_ranges override publish_config metric level active_time_ranges.",
    )


class IntradayPublishConfigDbTarget(IntradayPublishConfigTargetBase):
    target: Literal["db"]


class IntradayPublishConfigSecapiTarget(IntradayPublishConfigTargetBase):
    target: Literal["secapi"]


class IntradayPublishConfigBloombergTarget(IntradayPublishConfigTargetBase):
    target: Literal["bloomberg"]
    params: Optional[IntradayPublishConfigBloombergTargetParams] = None


class IntradayPublishConfigReutersTarget(IntradayPublishConfigTargetBase):
    target: Literal["reuters"]
    params: Optional[IntradayPublishConfigReutersTargetParams] = None


class RunState(BaseModel):
    status: RunStateStatus
    calculation_start_ts: Optional[
        constr(pattern=r"^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}:\d{2}(\.\d{6})?$", strict=True)
    ] = Field(
        None,
        description="set to the start of the last calculation, if the status is not PENDING_CREATION (has not ever started)",
        examples=["2022-01-02T01:02:03"],
    )
    error: Optional[StrictStr] = Field(None, description="An error message if status is FAILED")


class FsymAndCountry(BaseModel):
    fsym_id: StrictStr
    country_code: CountryCode


class ClientEquityBasketConfigBase(ClientIndexConfigBase):
    currency: StrictStr = Field("USD", description="set to the currency of the index", examples=["USD"])
    holiday_calendar: Optional[Union[FlatCalendarSchema, NestedCalendarSchema]] = None
    is_intraday: StrictBool = Field(
        False,
        description="set to true if the index is to calculate multiple times during the day. This does not pertain to the frequency of rebalancing; see `rebal_freq`. Even though theoretically all index family types can calculate multiple times a day, not all types will support this initially. This parameter is a bit experimental in that sense.",
        examples=[False],
    )


class ClientStaticBasketSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    base_value: float
    return_type: ReturnType
    reinvestment_time: ReinvestmentTime = ReinvestmentTime.AT_CLOSE
    reinvestment_type: ReinvestmentType = ReinvestmentType.INDEX
    rebalance_config: RebalanceConfig
    apply_mcap_screen: StrictBool = Field(
        True, description="set to true if the index should apply a 15% min market cap screen"
    )
    constituents: List[Constituent]
    rebalance_calendar: Optional[Union[FlatCalendarSchema, NestedCalendarSchema]] = None
    holiday_calendar_config: Optional[Union[LegacyStaticBasketCalendarConfig, StaticBasketCalendarConfig]] = None


class ClientDecrementSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fee_value: float = Field(
        ...,
        description="set to the value of the fee to apply. For fixed, this is bps, for percentage_pre/post this is given as a percentage",
        examples=[0.05],
    )
    fee_type: FeeType = Field(..., description="set to the type of fee to apply", examples=["fixed"])
    day_count_convention: StrictStr = Field(
        ...,
        description="must either adapt to a fixed number of days in a year e.g. 'f360' or to Actual ISDA convention, i.e. 'actual'",
        examples=["f360"],
    )
    underlying: ClientDecrementUnderlying = Field(..., examples=[{"identifier_type": "RIC", "identifier": "COST.OQ"}])
    start_date: Optional[date] = Field(
        None,
        description="set to the start date of the index if it is to differ from base_date. If this is specified, it must be before base_date. In this case the base_date, base_value is used as a fixed intercept, with the index level starting from start_date and passing through that intercept",
        examples=["2004-01-04"],
    )


class ClientMultiEBSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    corporate_actions: ClientEBCoraxConfig = Field(default_factory=ClientEBCoraxConfig)
    level_overrides: Optional[List[LevelOverride]] = Field(
        None,
        description="optional level overrides for the index on certain days.",
        examples=[
            [{"date": "2022-03-18", "level": 1364.344, "comment": "test for some special day for some special reason"}]
        ],
    )
    tick_configuration: Optional[TickConfiguration] = Field(
        None, description="config for the intraday index ticking start/end hour/minutes"
    )
    rebal_freq: Optional[RebalFrequency] = None
    precision_level: Optional[conint(ge=0)] = Field(
        None, description="used to set the rounding decimal field when creating identifiers"
    )
    dissemination_settings: Optional[List[DisseminationSetting]] = Field(
        None, description="array of configurations for setting up identifiers for individual providers"
    )


class ClientMultiEBPortUpdate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    constituents: List[Union[DatedBasketPosition, DatedRicEquityPosition, DatedFsymEquityPosition]] = Field(
        default_factory=list,
        description="The EB portfolio directory",
        examples=[
            [
                {
                    "date": "2022-03-11",
                    "identifier_type": "RIC",
                    "identifier": "AAPL.OQ",
                    "quantity": -0.2512355,
                    "security_type": "EQUITY",
                },
                {
                    "date": "2022-03-11",
                    "identifier_type": "RIC",
                    "identifier": "USD",
                    "quantity": 60.0,
                    "security_type": "CASH",
                },
            ]
        ],
    )
    unit_of_measure: PortfolioUom = PortfolioUom.SHARES
    index_currency: Optional[StrictStr] = None


class ClientMultiEBPortConfig(ClientMultiEBPortUpdate, ClientBaseVal):
    pass


class ClientStrategyOption(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    option_type: OptionType
    trade_type: TradeType
    strike_type: StrategyOptionStrikeType
    strike_value: Optional[confloat(ge=0.0)] = None
    exposure: confloat(ge=0.0)
    number_of_tranches: conint(ge=1)
    expiry: ClientStrategyOptionExpiry
    rebalance: Union[ClientStrategyOptionRebalanceRelativeToExpiry, ClientStrategyOptionRebalanceCertainDay]
    is_financing: StrictBool = False
    is_spread: StrictBool = False
    spread_lower_bound: Optional[float] = None
    spread_upper_bound: Optional[float] = None


class ClientStaticBasketConfig(ClientStaticBasketSpecific, ClientEquityBasketConfigBase):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class ClientSSTRConfig(ClientSSTRSpecific, ClientEquityBasketConfigBase):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class ClientDecrementConfig(ClientDecrementSpecific, ClientEquityBasketConfigBase):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class ClientMultiEBConfig(
    ClientMultiEBPortConfig, ClientMultiEBSpecific, ClientRuntimeInfo, ClientEquityBasketConfigBase
):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class StaticListingExclusionFilterSpec(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Literal["static_listing_exclusion"]
    static_listings: List[StaticListingDefinition]


class AllocationUnit(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    allocation_type: AllocationType
    allocation_name: StrictStr = Field(..., description="The name of the allocation unit")
    allocation_weight: confloat(ge=0.0, le=1.0)
    parent_index: Optional[StrictStr] = Field(
        None, description="The parent index for the allocation unit, if applicable"
    )
    weighting: WeightingSpec
    number_of_listings: Optional[int] = Field(
        None, description="The number of listings in the allocation unit, if null select all that apply"
    )
    ignore_double_listings: Optional[StrictBool] = None
    static_listings: Optional[List[StaticListingDefinition]] = None
    allocation_screens: Optional[
        List[
            Union[
                CountryOfDomicileFilterSpec,
                CountryOfExchangeFilterSpec,
                MicFilterSpec,
                SectorFilterSpec,
                SubSectorFilterSpec,
                TRBCFilterSpec,
                MarketCapFilterSpec,
                Advt3mFilterSpec,
                MarketCapPercentFilterSpec,
                StaticListingExclusionFilterSpec,
            ]
        ]
    ] = None


class RunConfig(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    airflow_config: Optional[AirflowConfig] = None
    command: Optional[StrictStr] = None
    command_arguments: Optional[List[List[StrictStr]]] = None
    index_report_uuids: Optional[List[StrictStr]] = None
    index_reports: Optional[Union[List[StrictStr], List[IndexReport]]] = None
    job_enabled: StrictBool
    holiday_calendar: Optional[Union[FlatCalendarSchema, NestedCalendarSchema]] = None
    pod_image_and_tag: Optional[StrictStr] = Field(None, description="overrides the image")
    schedule: Schedule
    alert_priority: Optional[AlertPriority] = None
    tzinfo: Optional[StrictStr] = None
    num_days_to_load: int
    day_chunk_size: Optional[int] = Field(
        None, description="if set to a number, the index run will be split into chunks of this number of days"
    )
    state_key: Optional[constr(min_length=1, strict=True)] = Field(
        None, description="ID to use when storing or reading the state of an instance of a dissapi object."
    )


class RunConfigLabel(RunConfig, RunConfigLabelAdditional):
    pass
    model_config = ConfigDict(
        extra="allow",
    )


class IntradayPublishConfigWrapper(BaseModel):
    publish_config: Optional[
        Dict[
            str,
            List[
                Union[
                    IntradayPublishConfigDbTarget,
                    IntradayPublishConfigSecapiTarget,
                    IntradayPublishConfigBloombergTarget,
                    IntradayPublishConfigReutersTarget,
                ]
            ],
        ]
    ] = None


class Intraday(IntradayPublishConfigWrapper):
    enabled: StrictBool = Field(..., description="If the intraday process should be run or not")
    security_id: Optional[StrictStr] = Field(
        None, description="Security ID of the intraday_index security where ticker data is served"
    )
    ticker_period: Optional[confloat(ge=1.0)] = Field(
        None, description="Duration between ticker datapoints. In seconds"
    )
    tzinfo: Optional[StrictStr] = Field(None, description="Timezone of intraday tick timestamp comparisons")
    active_time_ranges: Optional[List[IntradayTickFilter]] = None
    calculation_max_retry_delay: Optional[conint(ge=0)] = Field(
        None,
        description="How many seconds to keep retrying the real time calculation before setting the force flag. Defalts to 0 which means retry forever.",
    )
    resource_cpu_request: Optional[conint(ge=1)] = Field(
        None, description="Minimum cpu resources requested in milliCPU"
    )
    resource_memory_request: Optional[conint(ge=0)] = Field(
        None, description="Minimum memory resources requested in mebibytes."
    )
    heartbeat_timeout: Optional[conint(ge=1)] = Field(
        None, description="Max number of seconds between heartbeats before the rtindex pod is considered unhealthy"
    )
    startup_failure_timeout: Optional[conint(ge=1)] = Field(
        None,
        description="Max number of seconds to wait for the first heartbeat from the rtindex pod before considering it a failed startup. By default it will wait 40sec",
    )
    data_refresh_period: Optional[conint(ge=0)] = Field(
        None,
        description="After the rtindex refreshes its data this is the number of seconds to wait before refreshing again. 0 means do not refresh. Defaults to 3600 seconds (60min)",
    )
    tick_delay: Optional[conint(ge=0)] = Field(None, description="Number of seconds to delay intraday calculation")
    alerting: Optional[IntradayAlerting] = None


class IndexDefinitionPost(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    administrative: Administrative
    base_date: Optional[constr(pattern=r"^[0-9]{4}[-/][0-9]{2}[-/][0-9]{2}", strict=True)] = Field(
        None, description="the date that the index has level 'base_value'", examples=["2000-01-04"]
    )
    base_year: Optional[int] = None
    benchmark: Optional[Union[IndexBenchmark, List[IndexBenchmark]]] = None
    calc_freq: Optional[CalcFreq] = None
    currency: Optional[StrictStr] = None
    custom_metrics: Optional[List[MetricsSchema]] = None
    description: StrictStr
    display_month: Optional[DisplayMonth] = None
    documents: Optional[Dict[str, Any]] = None
    excess_strategy: Optional[Literal["keep_in_cash"]] = None
    family: Optional[StrictStr] = None
    family_description: Optional[StrictStr] = None
    family_codes: Optional[List[StrictStr]] = Field(None, max_length=1, min_length=1)
    first_value_date: Optional[constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True)] = Field(
        None,
        description="the first date that the index has a value; if set, will be < base_date",
        examples=["2000-01-04"],
    )
    identifiers: Optional[List[IdentifierUUIDRef]] = Field(None, min_length=0)
    intraday: Optional[Intraday] = None
    launch_date: StrictStr
    methodology: Optional[StrictStr] = None
    month: Optional[int] = None
    name: constr(pattern=r"^[a-zA-Z][a-zA-Z0-9-_]{0,99}$", strict=True)
    namespace: Optional[StrictStr] = None
    plot_metric: Optional[StrictStr] = None
    portfolio_allocation_display: Optional[StrictBool] = Field(
        None, description="whether or not portfolio_allocations are shown on the website. false by default"
    )
    portfolio_display: Optional[PortfolioDisplay] = None
    portfolio_handler_id: Optional[StrictStr] = None
    rebal_freq: Optional[RebalFrequency] = None
    related: Optional[List[Related]] = None
    run_configuration: Optional[RunConfig] = None
    run_configurations: Optional[List[RunConfigLabel]] = None
    sales_force_deal_id: Optional[StrictStr] = Field(None, description="SalesForce Deal ID")
    spec: Optional[IndexSpec] = None
    freezer_config: Optional[FreezerConfig] = None
    calculation_check: Optional[List[Union[LevelCheck, PercentChangeCheck, HistoryCheck]]] = None
    stage: Stage
    tags: Optional[StrictStr] = None
    title: StrictStr
    webpage: Optional[Webpage] = None
    weighting_method: Optional[WeightingMethod] = None
    eod_rt_price_check: Optional[StrictBool] = None
    notify_configuration: Optional[NotificationConfig] = None


class IndexDefinitionPatchPutGet(IndexDefinitionPost, CrudExtra):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class BasketPortfolioPutIn(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    positions: List[
        Union[
            BasketPosition,
            RicEquityPosition,
            FsymEquityPosition,
            OptionPosition,
            FuturesPosition,
            SecapiBasketPosition,
            MerqubeIndexPosition,
        ]
    ] = Field(..., title="Positions")
    timestamp: constr(pattern=r"^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}:\d{2}(\.\d{6})?$", strict=True) = Field(
        ..., description="the time at which the portfolio should take effect", examples=["2022-01-02T01:02:03"]
    )
    unit_of_measure: PortfolioUom
    share_selection_date: Optional[
        constr(pattern=r"^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}:\d{2}(\.\d{6})?$", strict=True)
    ] = Field(
        None,
        description="Share selection date, if specified, should be before the effective date (parameter 'timestamp') for this Target Portfolio. In case when the unit_of_measure is set to WEIGHT, we first determine the shares using the prices on the share selection date. If any constituent is de-listed by the share selection date, then that constituent's weight is distributed to other constituents before selecting the shares. We then apply the corporate actions from the share selection date to the day before the portfolio effective date. In case when the unit_of_measure is set to SHARES, we follow the similar steps as above, except the step of determining shares, as it is not needed.",
        examples=["2022-01-02T01:02:03"],
    )
    divisor: Optional[float] = Field(
        None, description="A scaling factor to apply for the SHARES of the portfolio constituents"
    )
    external_id: Optional[StrictStr] = Field(
        None, description="An external ID to reference this portfolio with. Must be unique per index."
    )


class BasketPortfolio(BasketPortfolioPutIn):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: StrictStr = Field(..., examples=["0000699a-fcd7-45d4-8ce4-064a4ffeced0"])
    status: PortfolioStatus = PortfolioStatus.FINAL
    status_change_reason: Optional[StrictStr] = None


class EventNotificationConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    PENDING_VALIDATION: Optional[TargetPortfolioHandlerNotificationConfig] = None
    FAILED_VALIDATION: Optional[TargetPortfolioHandlerNotificationConfig] = None
    PASSED_VALIDATION: Optional[TargetPortfolioHandlerNotificationConfig] = None
    SELECTED: Optional[TargetPortfolioHandlerNotificationConfig] = None
    UNSELECTED: Optional[TargetPortfolioHandlerNotificationConfig] = None
    FINAL: Optional[TargetPortfolioHandlerNotificationConfig] = None
    PAST_DEADLINE: Optional[TargetPortfolioHandlerNotificationConfig] = None


class TargetPortfolioHandlerPost(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: StrictStr
    namespace: StrictStr = Field(
        ...,
        description="the calling user must have permission to this namespace to create the handler in this namespace",
    )
    validation_window: Optional[TimestampWindow] = None
    selection_window: Optional[TimestampWindow] = None
    auto_select: Optional[StrictBool] = Field(
        None,
        description="If true, the handler will automatically select the last valid portfolio for an effective timestamp",
    )
    validator_fn: Optional[StrictStr] = None
    event_notification_config: Optional[EventNotificationConfig] = None


class ClientTemplateResponse(BaseModel):
    post_template: Optional[IndexDefinitionPost] = Field(None, description="a full index manifest that can be posted")
    bbg_ident_template: Optional[IdentifierUUIDPost] = Field(
        None, description="only returned if the client specified a bbg ticker"
    )
    target_ports: Optional[List[BasketPortfolioPutIn]] = Field(
        None, description="only returns for indices where the client should post the target portfolios"
    )


class IndexInterestRateConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    lending_rate: Union[ConstantInterestRateConfig, VariableInterestRateConfig] = Field(
        ..., description="configuration for an interest rate", discriminator="type"
    )
    borrowing_rate: Union[ConstantInterestRateConfig, VariableInterestRateConfig] = Field(
        ..., description="configuration for an interest rate", discriminator="type"
    )


class ClientEquityIndexSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: StrictStr
    return_type: ReturnType
    reinvestment_time: ReinvestmentTime
    reinvestment_type: Optional[ReinvestmentType] = ReinvestmentType.INDEX
    holiday_calendar: Union[FlatCalendarSchema, NestedCalendarSchema]
    rebalance_config: RebalanceConfig
    allocation_units: List[AllocationUnit] = Field(
        ...,
        description="The allocation units for the index, which define how the index constituents are grouped and weighted",
    )


class ClientDefinedOutcomeBufferStrategyItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    options: List[ClientDefinedOutcomeOption]
    expiry: ClientDefinedOutcomeExpiry
    rebalancer: ClientDefinedOutcomeRebalancer
    number_of_tranches: conint(ge=1) = Field(..., description="Number of tranches in the strategy")
    interest_rate_config: Optional[IndexInterestRateConfig] = Field(
        None, description="configuration for interest rates on an options strategy self service index"
    )
    self_financing_strategy: Optional[
        Union[ClientDefinedOutcomeParticipationRateStrategy, ClientDefinedOutComeNoEtfStrategy]
    ] = Field(None, discriminator="strategy")


class ClientDefinedOutcomeBufferStrategy(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    option_strategies: List[ClientDefinedOutcomeBufferStrategyItem] = Field(..., max_length=1, min_length=1)


class ClientDefinedOutcomeAcceleratorStrategyItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    options: List[ClientDefinedOutcomeOption] = Field(..., max_length=2, min_length=2)
    expiry: ClientDefinedOutcomeExpiry
    rebalancer: ClientDefinedOutcomeRebalancer
    number_of_tranches: conint(ge=1) = Field(..., description="Number of tranches in the strategy")
    interest_rate_config: Optional[IndexInterestRateConfig] = Field(
        None, description="configuration for interest rates on an options strategy self service index"
    )
    self_financing_strategy: Optional[ClientDefinedOutComeNoEtfStrategy] = None


class ClientDefinedOutcomeAcceleratorStrategy(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    option_strategies: List[ClientDefinedOutcomeAcceleratorStrategyItem] = Field(..., max_length=1, min_length=1)


class ClientDefinedOutcomeBufferBase(ClientDefinedOutcomeBufferStrategy):
    model_config = ConfigDict(
        extra="forbid",
    )
    strategy_type: Literal["BUFFER"]


class ClientDefinedOutcomeAcceleratorBase(ClientDefinedOutcomeAcceleratorStrategy):
    model_config = ConfigDict(
        extra="forbid",
    )
    strategy_type: Literal["ACCELERATOR"]


class ClientDefinedOutcomeBufferConfig(ClientDefinedOutcomeBufferBase, ClientRuntimeInfo, ClientIndexConfigBase):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class ClientDefinedOutcomeAcceleratorConfig(
    ClientDefinedOutcomeAcceleratorBase, ClientRuntimeInfo, ClientIndexConfigBase
):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class TargetPortfolioHandlerPatchPutGet(TargetPortfolioHandlerPost, CrudExtra):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class ClientOptionStrategiesBase(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    strategy_type: OptionStrategyType = Field(..., description="The type of strategy")
    underliers: List[Union[FsymAndCountry, IndexTicker]] = Field(
        ..., description="The underlying assets of the strategy", min_length=1
    )
    strategy_options: List[ClientStrategyOption] = Field(
        ..., description="List of options in the strategy and their configs"
    )
    hold_underlier: StrictBool = True
    interest_rate_config: Optional[IndexInterestRateConfig] = Field(
        None, description="configuration for interest rates on an options strategy self service index"
    )
    early_exercise: Optional[ClientStrategyOptionEarlyExercise] = None


class ClientOptionStrategiesConfig(ClientOptionStrategiesBase, ClientRuntimeInfo, ClientIndexConfigBase):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class ClientEquityIndexConfig(ClientIndexConfigBase, ClientEquityIndexSpecific):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


NestedCalendarSchema.model_rebuild()
