# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2023-10-12T20:41:50+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    PositiveFloat,
    StrictBool,
    StrictStr,
    confloat,
    conint,
    constr,
)
from typing_extensions import Literal


class Role(Enum):
    data_point = "data point"
    verification = "verification"
    calculation = "calculation"
    development = "development"
    administration = "administration"


class CalcFreq(Enum):
    Daily = "Daily"
    Daily__EOD = "Daily, EOD"
    Intraday = "Intraday"


class DisplayMonth(Enum):
    Jan = "Jan"
    Feb = "Feb"
    Mar = "Mar"
    Apr = "Apr"
    May = "May"
    Jun = "Jun"
    Jul = "Jul"
    Aug = "Aug"
    Sep = "Sep"
    Oct = "Oct"
    Nov = "Nov"
    Dec = "Dec"


class FieldModel(BaseModel):
    display_name: Optional[StrictStr] = None
    field_name: Optional[StrictStr] = None


class PortfolioDisplay(BaseModel):
    fields: Optional[List[FieldModel]] = None


class RebalFreq(Enum):
    Annual = "Annual"
    Daily = "Daily"
    Monthly = "Monthly"
    Quarterly = "Quarterly"
    Semi_Annual = "Semi-Annual"
    Weekly = "Weekly"
    Bi_Monthly = "Bi-Monthly"
    Intraday = "Intraday"
    None_ = "None"


class Stage(Enum):
    prod = "prod"
    test = "test"
    development = "development"


class WeightingMethod(Enum):
    Other = "Other"
    Equal = "Equal"


class IndexClassDefinitionPost(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(pattern=r"^[^!*\'() ;:@&=+$,/?%#\[\]]*$", strict=True)
    namespace: Optional[StrictStr] = None
    index_class_args_spec: Dict[str, Any]


class IndexSpec(BaseModel):
    index_class: Optional[StrictStr] = None
    index_class_args: Optional[Dict[str, Any]] = Field(
        None,
        description="should validate against index_class_args_spec field of the IndexClassDefinition identified by index_class",
    )
    index_variables: Optional[Dict[str, Any]] = Field(None, description="TODO")
    version: Optional[int] = None


class Type(Enum):
    security = "security"
    index = "index"


class Related(BaseModel):
    default_display: StrictBool = False
    id: StrictStr
    metric: Optional[StrictStr] = None
    name: StrictStr
    type: Type


class ChartType(Enum):
    line = "line"
    spline = "spline"
    area = "area"
    bar = "bar"
    column = "column"


class CompareMode(Enum):
    absolute = "absolute"
    percent = "percent"


class ConstructorType(Enum):
    chart = "chart"
    stockChart = "stockChart"


class Value(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    display_name: StrictStr
    path: StrictStr


class Datum(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    url: StrictStr
    array_field: StrictStr
    values: List[Value]
    key_field: StrictStr


class CustomCharts(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: StrictStr
    xlabel: StrictStr
    ylabel: StrictStr
    chart_type: ChartType = ChartType.line
    compare_mode: CompareMode = CompareMode.percent
    constructor_type: ConstructorType = ConstructorType.stockChart
    size: float = 12
    data: Optional[List[Datum]] = None


class IndexBenchmark(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ticker: StrictStr = Field(
        ..., description="accepts either FSYM_ID, or MQI:XXX to benchmark against another index.", example="MQI:XXX"
    )
    threshold: float = Field(
        ...,
        description="the deviation that triggers an outlier event, IE, the daily difference of the index vs the daily difference of the underlying should not be more than this percent",
        example=0.05,
    )
    index_metric: StrictStr = Field(
        "price_return",
        description="the metric of this index to compare against the ticker/threshold, eg can compare some other metric of this index than price_return",
        example="total_return",
    )
    benchmark_metric: StrictStr = Field(
        "price_return",
        description="only accepted if the ticker is an MQI. The metric of the benchmark index to compare against; eg can compare to some other metric than price_return of the benchmark",
        example="total_return",
    )


class Provider(Enum):
    bloomberg = "bloomberg"
    reuters = "reuters"
    morningstar = "morningstar"
    factset = "factset"
    nasdaq = "nasdaq"
    wind = "wind"
    secapi = "secapi"


class BloombergProviderKwargsPostType(Enum):
    EOD = "EOD"
    RT = "RT"
    EOD_AND_RT = "EOD_AND_RT"


class BloombergProviderKwargs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    post_type: BloombergProviderKwargsPostType


class ReutersProviderKwargsPostType(Enum):
    EOD = "EOD"
    RT = "RT"
    EOD_AND_RT = "EOD_AND_RT"


class ReutersProviderKwargs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    post_type: Optional[ReutersProviderKwargsPostType] = None


class SecapiProviderKwargs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    security_type: StrictStr
    security_name: StrictStr
    metric: StrictStr


class NasdaqEnv(Enum):
    testing = "testing"
    production = "production"


class NasdaqProviderKwargs(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    nasdaq_env: NasdaqEnv = Field(..., description="Which Nasdaq environment to send data to")
    eod_date_delta: Optional[int] = Field(
        None,
        description="How many days to offset the Nasdaq date (T if before 6:30pm EST otherwise T + 1) when getting EOD data from the Index",
    )


class Compression(Enum):
    NONE = "NONE"
    GZIP = "GZIP"


class LayoutType(Enum):
    SINGLE_FILE = "SINGLE_FILE"
    YEARLY_DIR_DAILY_FILE = "YEARLY_DIR_DAILY_FILE"


class DataCollectionsSpec(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    index_dc_subtype: StrictStr = Field(
        ..., description="Index Data Collection Subtype object key moves to array after transformation"
    )
    auto_persist: StrictBool = Field(
        False, description="Boolean to indicate whether to automatically persist the data. Default is false."
    )
    compression: Compression = Compression.GZIP
    date_col: StrictStr = "date"
    format: Literal["csv"] = "csv"
    layout_type: LayoutType = Field(
        LayoutType.SINGLE_FILE,
        description="SINGLE_FILE: one file. YEARLY_DIR_DAILY_FILE: one directory per year, each day, a file with YYYYMMDD format.",
    )
    location: StrictStr
    name: constr(pattern=r"^[A-Za-z0-9_]*$", min_length=3, max_length=128, strict=True)
    seed_file_path: Optional[StrictStr] = Field(None, description="Seed file for the data collection.")
    start_time: Optional[StrictStr] = None


class RealTimeTradeType(Enum):
    ELIGIBLE = "ELIGIBLE"
    INELIGIBLE = "INELIGIBLE"


class PortfolioUom(Enum):
    SHARES = "SHARES"
    WEIGHT = "WEIGHT"


class CountryCode(Enum):
    AE = "AE"
    AR = "AR"
    AT = "AT"
    AU = "AU"
    BD = "BD"
    BE = "BE"
    BG = "BG"
    BH = "BH"
    BR = "BR"
    BW = "BW"
    CA = "CA"
    CH = "CH"
    CI = "CI"
    CL = "CL"
    CN = "CN"
    CO = "CO"
    CY = "CY"
    CZ = "CZ"
    DE = "DE"
    DK = "DK"
    EC = "EC"
    EG = "EG"
    ES = "ES"
    FI = "FI"
    FR = "FR"
    GB = "GB"
    GR = "GR"
    HK = "HK"
    HR = "HR"
    HU = "HU"
    ID = "ID"
    IE = "IE"
    IL = "IL"
    IN = "IN"
    IS = "IS"
    IT = "IT"
    JP = "JP"
    KH = "KH"
    KR = "KR"
    KW = "KW"
    LK = "LK"
    LU = "LU"
    MX = "MX"
    MY = "MY"
    NL = "NL"
    False_ = False
    NZ = "NZ"
    PE = "PE"
    PH = "PH"
    PK = "PK"
    PL = "PL"
    PT = "PT"
    QA = "QA"
    RU = "RU"
    SA = "SA"
    SE = "SE"
    SG = "SG"
    SI = "SI"
    SK = "SK"
    TH = "TH"
    TN = "TN"
    TR = "TR"
    TT = "TT"
    TW = "TW"
    US = "US"
    VN = "VN"
    ZA = "ZA"
    ZM = "ZM"


class FsymSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    country_code: CountryCode = Field(..., example="US")


class EquityIdentifierType(Enum):
    RIC = "RIC"
    CURRENCY_CODE = "CURRENCY_CODE"
    SEDOL = "SEDOL"
    FSYM_ID = "FSYM_ID"
    TICKER = "TICKER"
    BBG_TICKER = "BBG_TICKER"
    CUSIP = "CUSIP"


class AssetType(Enum):
    CASH = "CASH"
    THIRD_PARTY_INDEX = "THIRD_PARTY_INDEX"
    EQUITY = "EQUITY"
    MUTUAL_FUND = "MUTUAL_FUND"
    MERQUBE_INDEX = "MERQUBE_INDEX"


class SecurityCreationResponse(BaseModel):
    id: Optional[StrictStr] = None
    inserts: Optional[int] = None


class DataType(Enum):
    string = "string"
    number64 = "number64"
    datetime64 = "datetime64"
    int64 = "int64"
    bool = "bool"
    object = "object"


class MetricsSchema(BaseModel):
    data_type: DataType
    description: StrictStr = Field(..., description="a description of what this metric represents")
    name: StrictStr = Field(..., description="metric name")
    object_schema: Optional[Dict[str, Any]] = Field(
        None,
        description="optional - this supports complex objects, ie you can specify the  metric is of this schema. THis allows you to upload a json schema itself of this metric. THis is for downstream users of this metric.",
    )


class IdentifierType(Enum):
    RIC = "RIC"
    secapi_name = "secapi_name"


class Security(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identifier_type: IdentifierType
    identifier_value: StrictStr = Field(..., example="AAPL.QQ")
    security_type: StrictStr = Field(..., example="equity")


class SecurityListPost(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(pattern=r"^[^!*\'() ;:@&=+$,/?%#\[\]]", strict=True) = Field(
        ..., description="unique name among all other security lists"
    )
    namespace: Optional[StrictStr] = None
    realtime: Optional[StrictBool] = None
    securities: List[Security]


class OptionResponse(BaseModel):
    price: Optional[float] = Field(None, description="Option Price")
    vol: Optional[float] = Field(None, description="Implied Volatility")
    interest_rate: Optional[float] = Field(None, description="Implied Interest Rate")
    dividend_yield: Optional[float] = Field(None, description="Implied Dividend Yield for the underlying")
    spot: Optional[float] = Field(None, description="Underlying spot price")
    delta: Optional[float] = Field(None, description="Delta of this option")
    theta: Optional[float] = Field(None, description="Theta of the option being priced")
    gamma: Optional[float] = Field(None, description="Gamma of the option being priced")
    vega: Optional[float] = Field(None, description="Vega of the option being priced")
    bid_ask_spread: Optional[float] = Field(
        None, description="Spread between Bid and Ask prices of the option being priced"
    )
    request_id: Optional[StrictStr] = Field(None, description="Request ID sent in the request")


class FindStrikeResponse(BaseModel):
    strike: Optional[float] = Field(None, description="Strike that prices to the given budget.")
    spot: Optional[float] = Field(None, description="Underlying spot price.")
    strike_percentage: Optional[float] = Field(
        None, description="Strike as a percentage of the underlying spot price that prices to the given budget."
    )
    request_id: Optional[StrictStr] = Field(None, description="Request ID sent in the request")


class DeadlineType(Enum):
    calculation = "calculation"
    restatement = "restatement"


class OgPriority(Enum):
    P1 = "P1"
    P2 = "P2"
    P3 = "P3"


class Deadline(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    time_of_day: constr(pattern=r"^(?:[01]\d|2[0-3]):(?:[0-5]\d):(?:[0-5]\d)$", strict=True) = Field(
        ..., description="the time of day of the deadline"
    )
    deadline_type: DeadlineType = DeadlineType.calculation
    next_day: StrictBool = Field(
        False,
        description="set this to true if the index starts running on day T but the deadline does not pass until T+1 in that index timezone",
    )
    og_priority: OgPriority = OgPriority.P1
    business_days_prior: int = Field(0, description="the amount of days before T to check for data existence")
    metrics: Optional[List[StrictStr]] = Field(
        None, description="the list of metrics to check in the deadline checker script"
    )


class MetricsArrItem(BaseModel):
    id: Optional[StrictStr] = Field(None, example="price_return")
    value: Optional[float] = Field(None, example=1000.0000000000002)


class MetricsDef(BaseModel):
    name: Optional[StrictStr] = Field(None, example="daily_return")
    type: Optional[StrictStr] = Field(None, example="double")


class ErrorCodes(BaseModel):
    code: Optional[StrictStr] = None
    message: Optional[StrictStr] = None


class IntradayPublishConfigBloombergTargetParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    rounding_decimals: Optional[int] = None
    ticker: Optional[StrictStr] = None


class IntradayPublishConfigReutersTargetParams(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    rounding_decimals: Optional[int] = None
    ticker: Optional[StrictStr] = None
    post_type: Optional[ReutersProviderKwargsPostType] = None


class RunStateStatus(Enum):
    PENDING_CREATION = "PENDING_CREATION"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    RUNNING = "RUNNING"


class ClientBaseVal(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    base_date: constr(pattern=r"^[0-9]{4}[-/][0-9]{2}[-/][0-9]{2}", strict=True) = Field(
        ..., description="the date that the index has level 'base_value'", example="2000-01-04"
    )
    base_value: PositiveFloat = Field(
        ..., description="set the index value on base_date to this base_value", example=1000.0
    )


class ClientIndexBaseProperties(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bbg_ticker: Optional[StrictStr] = Field(
        None,
        description="due to the limitations of the Bloomberg ticker creation process (no API), this must be a pre-created ticker. You can email MerQube a list of tickers to create on your behalf at support@merqube.com. Then, you provide those as input to these indices",
        example="MY_TICKER",
    )
    description: StrictStr = Field(
        ...,
        description="set to the description of the index, which will show on merqube.com",
        example="My Index Description",
    )
    email_list: List[StrictStr] = Field(
        default_factory=list,
        description="list of emails to send daily dissemination reports, and the initial backtest reports, to; if not specified, no emails will be sent",
        example=["bob@mycompany.com", "alice@mycompany.com"],
    )
    name: constr(pattern=r"^[^!*\'() ;:@&=+$,/?%#\[\]]", strict=True) = Field(
        ...,
        description="set to the name of the index. Commonly people use the ticker as the name, but that is not necessary. Must be globally unique - you will get a 409 if this index name is taken ",
        example="My Index",
    )
    namespace: StrictStr = Field(..., description="set to the namespace of the index", example="mycompany")
    title: StrictStr = Field(
        ..., description="set to the title of the index that shows up on merqube.com", example="My Index Title"
    )


class ClientIndexConfigBase(ClientBaseVal, ClientIndexBaseProperties):
    pass


class ReinvestmentType(Enum):
    AT_OPEN = "AT_OPEN"
    AT_CLOSE = "AT_CLOSE"


class ClientSSTRSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ric: StrictStr = Field(..., description="set to the RIC of the underlying equity", example="LMVH.PA")
    reinvestment_type: ReinvestmentType = ReinvestmentType.AT_OPEN


class FeeType(Enum):
    fixed = "fixed"
    percentage_pre = "percentage_pre"
    percentage_post = "percentage_post"


class ClientDecrementUnderlyingIDType(Enum):
    RIC = "RIC"
    MERQUBE_INDEX = "MERQUBE_INDEX"


class ClientDecrementUnderlying(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identifier_type: ClientDecrementUnderlyingIDType
    identifier: StrictStr = Field(..., example="COST.OQ")


class LevelOverride(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True) = Field(..., example="2000-01-04")
    level: float
    comment: Optional[StrictStr] = None


class ClientEBCoraxConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    reinvest_dividends: StrictBool = Field(True, example=False)


class ClientMultiEBSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    corporate_actions: ClientEBCoraxConfig = Field(default_factory=ClientEBCoraxConfig)
    level_overrides: Optional[List[LevelOverride]] = Field(
        None,
        description="optional level overrides for the index on certain days.",
        example=[
            {"date": "2022-03-18", "level": 1364.344, "comment": "test for some special day for some special reason"}
        ],
    )


class ClientRuntimeInfo(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    run_hour: int = Field(
        ..., description="set to the hour of day to run the index in the index's timezone", example=16
    )
    run_minute: int = Field(..., description="set to the minute of the hour to run the index ", example=30)
    timezone: StrictStr = Field("US/Eastern", description="set to the timezone of the index", example="US/Eastern")


class ExcessStrategy(Enum):
    keep_in_cash = "keep_in_cash"
    buy_call = "buy_call"


class Root(Enum):
    SPY = "SPY"
    QQQ = "QQQ"


class ClientBufferSpecific(BaseModel):
    buffer_start: confloat(ge=0.0, le=1.0) = Field(
        ...,
        description="losses on the underlying are incurred up to (1-buffer_start), the portfolio is protected between (1-start) and (1-end), and then losses after (1-end) are also incurred. Eg on start=0.95 and end=0.7 (a so called 5/30 buffer), the first 5% of losses are incurred, the portfolio is protected between 5 and 30, then losses after 30 are added to 5 and are incurred.",
        example=0.95,
    )
    buffer_end: confloat(ge=0.0, le=1.0) = Field(
        ..., description="eg the 30 in the above example. Must be < buffer_start.", example=0.7
    )
    excess_strategy: ExcessStrategy = Field(
        ExcessStrategy.buy_call, description="strategy for unused cash", example="keep_in_cash"
    )
    fee: confloat(ge=0.0, le=1.0) = Field(
        0.0, description="expressed as a percentage of the transaction cost", example=0.05
    )
    roll_freq: conint(ge=1) = Field(12, description="frequency in months of the options roll", example=3)
    root: Root = Field(..., description="the root of the options", example="SPY")
    use_eod_spot: StrictBool = Field(
        True,
        description="if this is true, the end of day spot price is used to price the option. If this is false, MerQube's option pricer is used to compute the implied price.",
        example=False,
    )


class ClientBufferConfig(ClientBufferSpecific, ClientRuntimeInfo, ClientIndexConfigBase):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class Status(BaseModel):
    created_at: Optional[StrictStr] = None
    created_by: Optional[StrictStr] = None
    last_modified: StrictStr
    last_modified_by: Optional[StrictStr] = None
    locked_after: Optional[datetime] = Field(
        None,
        description="If this is set (non null), the manifest is locked for all edits to any other field after this timestamp. A PUT/PATCH may be used to first unlock the manifest, by setting this field (to a max of one hour in the future), or to `null` again, to make other edits.",
    )


class CalendarIdentifiers(BaseModel):
    calendar_identifiers: Optional[List[constr(pattern=r"^(FUT|MIC|FX|SM|MQI):.+$", strict=True)]] = None


class HolidaysToAdd(BaseModel):
    holidays_to_add: Optional[List[date]] = None


class Operator(Enum):
    union = "union"
    intersection = "intersection"
    difference = "difference"


class NestedCalendarSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    operator: Operator
    children: List[Union[CalendarIdentifiers, HolidaysToAdd, NestedCalendarSchema]]


class Condition(Enum):
    any = "any"
    all = "all"
    custom = "custom"


class WeekmaskEnum(Enum):
    Mon = "Mon"
    Tue = "Tue"
    Wed = "Wed"
    Thu = "Thu"
    Fri = "Fri"
    Sat = "Sat"
    Sun = "Sun"


class FlatCalendarSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    calendar_identifiers: List[constr(pattern=r"^(FUT|MIC|FX|SM|MQI):.+$", strict=True)] = Field(default_factory=list)
    swaps_monitor_codes: List[constr(pattern=r"^[a-zA-Z]{3}$", strict=True)] = Field(default_factory=list)
    condition: Condition = Condition.all
    holidays_to_add: List[date] = Field(default_factory=list)
    holidays_to_remove: List[date] = Field(default_factory=list)
    weekmask: List[WeekmaskEnum] = Field(
        [WeekmaskEnum.Mon, WeekmaskEnum.Tue, WeekmaskEnum.Wed, WeekmaskEnum.Thu, WeekmaskEnum.Fri],
        description="weekmask of valid business days",
    )


class PodKwargs(BaseModel):
    name: Optional[StrictStr] = None


class SubPod(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    arguments: Optional[List[List[StrictStr]]] = None
    command: StrictStr
    pod_type: StrictStr
    uuid: StrictStr
    env_vars: Optional[List[List[StrictStr]]] = None
    pod_kwargs: Optional[PodKwargs] = None


class S3Bucket(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bucket: StrictStr
    path: Optional[StrictStr] = None


class AirflowConfig(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    description: Optional[StrictStr] = Field(None, description="A short description related with the generated runner")
    s3_location: Optional[S3Bucket] = Field(
        None,
        description="Bucket and path where the generated dag should be stored. If not defined `merq-airflow-dags-airflow2` is defined in merqutil",
    )
    dag: Optional[Dict[str, Any]] = Field(None, description="use this to set kwargs for the dag")
    pod: Optional[Dict[str, Any]] = Field(None, description="use this to set kwargs for the pod")
    env: Optional[Dict[str, Any]] = Field(None, description="use this to set ENV variables in the pod")
    subpods: Optional[List[SubPod]] = None


class EmailDissapiConfig(BaseModel):
    recipient_list: List[StrictStr] = Field(..., min_length=1)
    email_list: Optional[List[StrictStr]] = None
    bcc_list: Optional[List[StrictStr]] = None
    cc_list: Optional[List[StrictStr]] = None
    subject: StrictStr
    content: Optional[StrictStr] = None
    file_keys: Optional[List[StrictStr]] = None


class SftpDissapiConfig(BaseModel):
    sftp_ids: List[StrictStr]
    file_keys: List[StrictStr]


class S3DissapiConfig(BaseModel):
    bucket: StrictStr
    key_prefix: StrictStr
    file_keys: List[StrictStr]


class DisseminationDestinations(BaseModel):
    email_dissapi_configs: Optional[List[EmailDissapiConfig]] = Field(None, min_length=1)
    sftp_dissapi_configs: Optional[List[SftpDissapiConfig]] = None
    s3_dissapi_configs: Optional[List[S3DissapiConfig]] = None


class IndexReport(BaseModel):
    uuid: StrictStr
    program_args: Optional[Dict[str, Any]] = None
    dissemination_destinations: Optional[DisseminationDestinations] = None


class RunConfigLabelAdditional(BaseModel):
    label: StrictStr = Field(..., description="unique label of this rc")


class HolidayCalendar(BaseModel):
    cal_type: Optional[StrictStr] = Field(None, example="MIC")
    mic: Optional[StrictStr] = Field(None, example="XNYS")


class Schedule(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    retries: int
    retry_interval_min: int
    schedule_start: StrictStr
    schedule_cron: Optional[StrictStr] = None
    timeout_delta: Optional[StrictStr] = Field(None, example="minutes=17")
    business_days_prior: Optional[int] = Field(None, example=1)
    holiday_calendar: Optional[HolidayCalendar] = None


class CopyFromManifest(BaseModel):
    copy_from_uuid: StrictStr = Field(..., description="the uuid of the resource to start from")
    field_deletes: Optional[List[StrictStr]] = Field(None, description="fields to delete from the from-manifest")
    field_updates: Optional[Dict[str, Any]] = Field(
        None,
        description="a dictionary of top level keys that the original manifest will be updated with (ie `manifest.update(this[field_updates])`. Top level keys can be added or replaced. To change the namespace, add namespace to the field_updates dict. The new manifest must be valid per the original resource definition.",
    )
    name: StrictStr = Field(..., description="the name of the new resource")


class CrudExtra(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: StrictStr
    namespace: StrictStr
    status: Status


class Administrative(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    role: Role
    deadlines: Optional[List[Deadline]] = None


class IndexClassDefinitionPatchPutGet(IndexClassDefinitionPost, CrudExtra):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class Webpage(BaseModel):
    custom_charts: Optional[List[CustomCharts]] = None
    visible: StrictBool = True


class IdentifierUUIDPost(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    display_name: Optional[StrictStr] = None
    index_name: StrictStr
    metric: Optional[StrictStr] = None
    name: constr(pattern=r"^[^!*\'() ;:@&=+$,/?%#\[\]]", strict=True) = Field(
        ..., description="unique name among all other Identifiers of the provider resource type."
    )
    namespace: Optional[StrictStr] = None
    rounding_decimals: Optional[int] = None
    provider_kwargs: Optional[
        Union[BloombergProviderKwargs, ReutersProviderKwargs, SecapiProviderKwargs, NasdaqProviderKwargs]
    ] = None
    start_date: Optional[date] = None
    ticker: StrictStr


class IdentifierUUIDPatchPutGet(IdentifierUUIDPost, CrudExtra):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class IdentifierUUIDRef(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: StrictStr
    provider: Provider


class ListDataCollections(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    data_collection: List[DataCollectionsSpec] = Field(default_factory=list)


class BasketPosition(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: float = Field(..., title="Amount")
    asset_type: AssetType
    identifier: StrictStr = Field(..., title="Identifier")
    identifier_type: EquityIdentifierType
    position_id: Optional[StrictStr] = Field(None, example="1", title="Position Id")


class DatedBasketPosition(BasketPosition):
    date: constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True) = Field(..., example="2000-01-04")


class RicSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identifier_type: Optional[EquityIdentifierType] = None
    real_time_trade_types: Optional[List[RealTimeTradeType]] = None
    use_primary_listing: StrictBool = Field(
        False,
        description="use the security's primary listing rather than the one from the identifier",
        title="Use Primary Listing",
    )


class RicEquityPosition(BasketPosition, RicSpecific):
    pass


class DatedRicEquityPosition(DatedBasketPosition, RicSpecific):
    pass


class FsymEquityPosition(BasketPosition, FsymSpecific):
    pass


class DatedFsymEquityPosition(DatedBasketPosition, FsymSpecific):
    pass


class NewSecurity(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(pattern=r"^[^!*\'() ;:@&=+$,/?%#\[\]]", strict=True)
    namespace: StrictStr = Field(
        ...,
        description="the calling user must have permission to this namespace to create the security in this namespace",
    )
    eff_ts: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(
        None,
        description="DEPRECATED: this is no longer used for security creates, but allowed for backwards compatibility",
        example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"],
    )
    prov_ts: Union[
        datetime,
        date,
        constr(
            pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1,6})?$", strict=True
        ),
    ] = Field(..., example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"])
    source: Optional[StrictStr] = None


class SecurityMetrics(BaseModel):
    eff_ts: Union[
        datetime,
        date,
        constr(
            pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1,6})?$", strict=True
        ),
    ] = Field(..., example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"])
    id: StrictStr = Field(..., example="0000699a-fcd7-45d4-8ce4-064a4ffeced0")
    metric: StrictStr = Field(..., example="Level")
    source: Optional[StrictStr] = Field(None, example="some_gcp_feed")
    prov_ts: Union[
        datetime,
        date,
        constr(
            pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1,6})?$", strict=True
        ),
    ] = Field(..., example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"])
    value: Union[StrictStr, float, int, StrictBool, List, Dict[str, Any]]


class SecurityMetricsDeletion(BaseModel):
    eff_ts: Union[
        datetime,
        date,
        constr(
            pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1,6})?$", strict=True
        ),
    ] = Field(..., example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"])
    id: StrictStr = Field(..., example="0000699a-fcd7-45d4-8ce4-064a4ffeced0")
    metric: StrictStr = Field(..., example="Level")
    prov_ts: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"])
    source: Optional[StrictStr] = Field(None, example="some_gcp_feed")


class SecurityListPatchPutGet(SecurityListPost, CrudExtra):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class Metrics(BaseModel):
    ts: Optional[datetime] = Field(None, description="iso8601 format")
    metrics: Optional[List[MetricsArrItem]] = None


class Stats(BaseModel):
    annual_volatility: Optional[float] = Field(None, example=3.717606464173326)
    annualized_return: Optional[float] = Field(None, example=6.665050717276233)
    cumulative_return: Optional[float] = Field(None, example=2.7597506251556547)
    id: Optional[StrictStr] = Field(None, example="YTD")
    max_drawdown: Optional[float] = Field(None, example=-1.3877029296510448)
    sharpe_ratio: Optional[float] = Field(None, example=1.759543308780235)
    start_date: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"])
    end_date: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"])


class IntradayTickFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    start_date: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"])
    end_date: Optional[
        Union[
            datetime,
            date,
            constr(
                pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?(?:[.][0-9]{1, 6})?$",
                strict=True,
            ),
        ]
    ] = Field(None, example=["2021-01-01", "2021-01-01T01:01:01", "2021-01-01T01:01:01.zzzzz"])
    start_time: Optional[StrictStr] = Field(
        None,
        description="Inclusive start time of the day to start running this intraday index. Format is %H:%M:%S.%f. This should be in the timezone of the index based on tzinfo.",
        example=74340.262345,
    )
    end_time: Optional[StrictStr] = Field(
        None,
        description="Inclusive end time of the day to stop running this intraday index. Format is %H:%M:%S.%f. This should be in the timezone of the index based on tzinfo.",
        example=74340.262345,
    )
    days_of_week: Optional[List[int]] = Field(
        None,
        description="Which days of the week to run the index. Each day of the week is denoted by an integer with Monday = 0 and Sunday = 6",
    )
    exclude_holidays: Optional[StrictBool] = Field(
        None,
        description="If this is true use the index holiday calendar to decide which days to run the index. It will only run on non-holidays.",
    )


class IntradayPublishConfigTargetBase(BaseModel):
    active_time_ranges: Optional[List[IntradayTickFilter]] = Field(
        None,
        description="Time ranges during which values should be published to this target. Target level active_time_ranges override publish_config metric level active_time_ranges.",
    )


class IntradayPublishConfigDbTarget(IntradayPublishConfigTargetBase):
    target: Literal["db"]


class IntradayPublishConfigSecapiTarget(IntradayPublishConfigTargetBase):
    target: Literal["secapi"]


class IntradayPublishConfigBloombergTarget(IntradayPublishConfigTargetBase):
    target: Literal["bloomberg"]
    params: Optional[IntradayPublishConfigBloombergTargetParams] = None


class IntradayPublishConfigReutersTarget(IntradayPublishConfigTargetBase):
    target: Literal["reuters"]
    params: Optional[IntradayPublishConfigReutersTargetParams] = None


class RunState(BaseModel):
    status: RunStateStatus
    calculation_start_ts: Optional[
        constr(pattern=r"^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}:\d{2}(\.\d{6})?$", strict=True)
    ] = Field(
        None,
        description="set to the start of the last calculation, if the status is not PENDING_CREATION (has not ever started)",
        example="2022-01-02T01:02:03",
    )
    error: Optional[StrictStr] = Field(None, description="An error message if status is FAILED")


class ClientEquityBasketConfigBase(ClientIndexConfigBase):
    currency: StrictStr = Field("USD", description="set to the currency of the index", example="USD")
    holiday_calendar: Optional[Union[FlatCalendarSchema, NestedCalendarSchema]] = None
    is_intraday: StrictBool = Field(
        False,
        description="set to true if the index is to calculate multiple times during the day. This does not pertain to the frequency of rebalancing; see `rebal_freq`. Even though theoretically all index family types can calculate multiple times a day, not all types will support this initially. This parameter is a bit experimental in that sense.",
        example=False,
    )


class ClientDecrementSpecific(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fee_value: float = Field(
        ...,
        description="set to the value of the fee to apply. For fixed, this is bps, for percentage_pre/post this is given as a percentage",
        example=0.05,
    )
    fee_type: FeeType = Field(..., description="set to the type of fee to apply", example="fixed")
    day_count_convention: StrictStr = Field(
        ...,
        description="must either adapt to a fixed number of days in a year e.g. 'f360' or to Actual ISDA convention, i.e. 'actual'",
        example="f360",
    )
    underlying: ClientDecrementUnderlying = Field(..., example={"identifier_type": "RIC", "identifier": "COST.OQ"})
    start_date: Optional[date] = Field(
        None,
        description="set to the start date of the index if it is to differ from base_date. If this is specified, it must be before base_date. In this case the base_date, base_value is used as a fixed intercept, with the index level starting from start_date and passing through that intercept",
        example="2004-01-04",
    )


class ClientMultiEBPortUpdate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    constituents: List[Union[DatedBasketPosition, DatedRicEquityPosition, DatedFsymEquityPosition]] = Field(
        default_factory=list,
        description="The EB portfolio directory",
        example=[
            {
                "date": "2022-03-11",
                "identifier_type": "RIC",
                "identifier": "AAPL.OQ",
                "quantity": -0.2512355,
                "security_type": "EQUITY",
            },
            {
                "date": "2022-03-11",
                "identifier_type": "RIC",
                "identifier": "USD",
                "quantity": 60.0,
                "security_type": "CASH",
            },
        ],
    )


class ClientMultiEBPortConfig(ClientMultiEBPortUpdate, ClientBaseVal):
    unit_of_measure: PortfolioUom = PortfolioUom.SHARES


class ClientSSTRConfig(ClientSSTRSpecific, ClientEquityBasketConfigBase):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class ClientDecrementConfig(ClientDecrementSpecific, ClientEquityBasketConfigBase):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class ClientMultiEBConfig(
    ClientMultiEBPortConfig, ClientMultiEBSpecific, ClientRuntimeInfo, ClientEquityBasketConfigBase
):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class RunConfig(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    airflow_config: Optional[AirflowConfig] = None
    command: Optional[StrictStr] = None
    command_arguments: Optional[List[List[StrictStr]]] = None
    index_report_uuids: Optional[List[StrictStr]] = None
    index_reports: Optional[Union[List[StrictStr], List[IndexReport]]] = None
    job_enabled: StrictBool
    holiday_calendar: Optional[Union[FlatCalendarSchema, NestedCalendarSchema]] = None
    pod_image_and_tag: Optional[StrictStr] = Field(None, description="overrides the image")
    schedule: Schedule
    tzinfo: Optional[StrictStr] = None


class RunConfigLabel(RunConfig, RunConfigLabelAdditional):
    pass
    model_config = ConfigDict(
        extra="allow",
    )


class IntradayPublishConfigWrapper(BaseModel):
    publish_config: Optional[
        Dict[
            str,
            List[
                Union[
                    IntradayPublishConfigDbTarget,
                    IntradayPublishConfigSecapiTarget,
                    IntradayPublishConfigBloombergTarget,
                    IntradayPublishConfigReutersTarget,
                ]
            ],
        ]
    ] = None


class Intraday(IntradayPublishConfigWrapper):
    enabled: StrictBool = Field(..., description="If the intraday process should be run or not")
    security_id: Optional[StrictStr] = Field(
        None, description="Security ID of the intraday_index security where ticker data is served"
    )
    ticker_period: Optional[float] = Field(None, description="Duration between ticker datapoints. In seconds")
    tzinfo: Optional[StrictStr] = Field(None, description="Timezone of intraday tick timestamp comparisons")
    active_time_ranges: Optional[List[IntradayTickFilter]] = None
    calculation_max_retry_delay: Optional[conint(ge=0)] = Field(
        None,
        description="How many seconds to keep retrying the real time calculation before setting the force flag. Defalts to 0 which means retry forever.",
    )
    resource_cpu_request: Optional[conint(ge=1)] = Field(
        None, description="Minimum cpu resources requested in milliCPU"
    )
    resource_memory_request: Optional[conint(ge=0)] = Field(
        None, description="Minimum memory resources requested in mebibytes."
    )
    heartbeat_timeout: Optional[conint(ge=1)] = Field(
        None, description="Max number of seconds between heartbeats before the rtindex pod is considered unhealthy"
    )
    startup_failure_timeout: Optional[conint(ge=1)] = Field(
        None,
        description="Max number of seconds to wait for the first heartbeat from the rtindex pod before considering it a failed startup. By default it will wait 40sec",
    )
    data_refresh_period: Optional[conint(ge=0)] = Field(
        None,
        description="After the rtindex refreshes its data this is the number of seconds to wait before refreshing again. 0 means do not refresh. Defaults to 3600 seconds (60min)",
    )


class IndexDefinitionPost(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    administrative: Administrative
    base_date: Optional[constr(pattern=r"^[0-9]{4}[-/][0-9]{2}[-/][0-9]{2}", strict=True)] = Field(
        None, description="the date that the index has level 'base_value'", example="2000-01-04"
    )
    base_year: Optional[int] = None
    benchmark: Optional[Union[IndexBenchmark, List[IndexBenchmark]]] = None
    buffer_end: Optional[float] = None
    buffer_start: Optional[float] = None
    calc_freq: Optional[CalcFreq] = None
    currency: Optional[StrictStr] = None
    custom_metrics: Optional[List[MetricsSchema]] = None
    description: StrictStr
    display_month: Optional[DisplayMonth] = None
    documents: Optional[Dict[str, Any]] = None
    excess_strategy: Optional[Literal["keep_in_cash"]] = None
    family: StrictStr
    family_description: Optional[StrictStr] = None
    first_value_date: Optional[constr(pattern=r"^[0-9]{4}-[0-9]{2}-[0-9]{2}", strict=True)] = Field(
        None, description="the first date that the index has a value; if set, will be < base_date", example="2000-01-04"
    )
    identifiers: Optional[List[IdentifierUUIDRef]] = Field(None, min_length=0)
    index_class_uuid: Optional[StrictStr] = None
    intraday: Optional[Intraday] = None
    launch_date: StrictStr
    methodology: Optional[StrictStr] = None
    month: Optional[int] = None
    name: constr(pattern=r"^[a-zA-Z][a-zA-Z0-9-_]{0,99}$", strict=True)
    namespace: Optional[StrictStr] = None
    plot_metric: Optional[StrictStr] = None
    portfolio_allocation_display: Optional[StrictBool] = Field(
        None, description="whether or not portfolio_allocations are shown on the website. false by default"
    )
    portfolio_display: Optional[PortfolioDisplay] = None
    rebal_freq: Optional[RebalFreq] = None
    related: Optional[List[Related]] = None
    run_configuration: Optional[RunConfig] = None
    run_configurations: Optional[List[RunConfigLabel]] = None
    spec: Optional[IndexSpec] = None
    stage: Stage
    tags: Optional[StrictStr] = None
    title: StrictStr
    webpage: Optional[Webpage] = None
    weighting_method: Optional[WeightingMethod] = None


class IndexDefinitionPatchPutGet(IndexDefinitionPost, CrudExtra):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class EquityBasketPortfolio(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    positions: List[Union[BasketPosition, RicEquityPosition, FsymEquityPosition]] = Field(..., title="Positions")
    timestamp: constr(pattern=r"^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}:\d{2}(\.\d{6})?$", strict=True) = Field(
        ..., description="the time at which the portfolio should take effect", example="2022-01-02T01:02:03"
    )
    unit_of_measure: PortfolioUom
    share_selection_date: Optional[
        constr(pattern=r"^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}:\d{2}(\.\d{6})?$", strict=True)
    ] = Field(
        None,
        description="Share selection date, if specified, should be before the effective date (parameter 'timestamp') for this Target Portfolio. In case when the unit_of_measure is set to WEIGHT, we first determine the shares using the prices on the share selection date. If any constituent is de-listed by the share selection date, then that constituent's weight is distributed to other constituents before selecting the shares. We then apply the corporate actions from the share selection date to the day before the portfolio effective date. In case when the unit_of_measure is set to SHARES, we follow the similar steps as above, except the step of determining shares, as it is not needed.",
        example="2022-01-02T01:02:03",
    )
    divisor: Optional[float] = Field(
        None, description="A scaling factor to apply for the SHARES of the portfolio constituents"
    )


class ClientTemplateResponse(BaseModel):
    post_template: Optional[IndexDefinitionPost] = Field(None, description="a full index manifest that can be posted")
    bbg_ident_template: Optional[IdentifierUUIDPost] = Field(
        None, description="only returned if the client specified a bbg ticker"
    )
    target_ports: Optional[List[EquityBasketPortfolio]] = Field(
        None, description="only returns for indices where the client should post the target portfolios"
    )


NestedCalendarSchema.model_rebuild()
